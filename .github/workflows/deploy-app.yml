# .github/workflows/deploy-app.yml
# PHP 애플리케이션 배포 워크플로우 (server 폴더 변경시만 실행)

name: Deploy PHP Application

on:
  push:
    branches: [ main ]
    paths:
      - 'WALB/server/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'WALB/server/**'

env:
  PROJECT_NAME: "walb-app"
  
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    # 워킹 디렉토리를 WALB로 설정
    defaults:
      run:
        working-directory: ./WALB
    
    permissions:
      id-token: write
      contents: read
    
    steps:
    # ===============================================
    # 소스코드 체크아웃
    # ===============================================
    - name: Checkout code
      uses: actions/checkout@v4
    
    # ===============================================
    # PHP 및 Composer 환경 설정
    # ===============================================
    - name: Set up PHP
      uses: shivammathur/setup-php@v2
      with:
        php-version: '8.1'
        extensions: pdo, pdo_pgsql, mbstring, xml, zip, gd
        coverage: none
    
    - name: Validate Composer
      run: |
        echo "🔍 PHP 애플리케이션 검증 중..."
        if [ -f "server/composer.json" ]; then
          cd server
          composer validate --no-check-publish
          composer install --no-dev --optimize-autoloader --no-interaction
          echo "✅ Composer 검증 완료"
        else
          echo "ℹ️ Composer 파일이 없습니다. Docker 빌드만 실행합니다."
        fi
    
    # ===============================================
    # AWS 인증 (OIDC 방식)
    # ===============================================
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN_APP }}
        aws-region: ${{ secrets.AWS_REGION }}
        role-session-name: GitHubActions-Application-${{ github.run_id }}

    # ===============================================
    # 기존 인프라 정보 조회
    # ===============================================
    - name: Get Infrastructure Resources
      run: |
        echo "🔍 기존 인프라 리소스 정보 조회 중..."
        
        # ECR 리포지토리 URI 조회
        ECR_REPO=$(aws ecr describe-repositories --repository-names ${PROJECT_NAME}-ecr --query 'repositories[0].repositoryUri' --output text 2>/dev/null || echo "")
        if [ -z "$ECR_REPO" ]; then
          echo "❌ ECR 리포지토리를 찾을 수 없습니다: ${PROJECT_NAME}-ecr"
          echo "먼저 인프라 배포가 필요합니다."
          exit 1
        fi
        echo "ECR_REPOSITORY=$ECR_REPO" >> $GITHUB_ENV
        echo "✅ ECR Repository: $ECR_REPO"
        
        # EKS 클러스터 이름 조회
        EKS_CLUSTER=$(aws eks describe-cluster --name walb-eks-cluster --query 'cluster.name' --output text 2>/dev/null || echo "")
        if [ -z "$EKS_CLUSTER" ] || [ "$EKS_CLUSTER" == "None" ]; then
          echo "❌ EKS 클러스터를 찾을 수 없습니다: ${PROJECT_NAME}-eks"
          echo "먼저 인프라 배포가 필요합니다."
          exit 1
        fi
        echo "EKS_CLUSTER_NAME=$EKS_CLUSTER" >> $GITHUB_ENV
        echo "✅ EKS Cluster: $EKS_CLUSTER"
        
        # RDS 엔드포인트 조회
        RDS_ENDPOINT=$(aws rds describe-db-instances --query 'DBInstances[?DBName==`mydb`].Endpoint.Address' --output text 2>/dev/null || echo "")
        if [ -z "$RDS_ENDPOINT" ] || [ "$RDS_ENDPOINT" == "None" ]; then
          echo "❌ RDS 인스턴스를 찾을 수 없습니다"
          echo "먼저 인프라 배포가 필요합니다."
          exit 1
        fi
        echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV
        echo "✅ RDS Endpoint: $RDS_ENDPOINT"
        
        # EKS 클러스터 상태 확인
        EKS_STATUS=$(aws eks describe-cluster --name $EKS_CLUSTER --query 'cluster.status' --output text)
        if [ "$EKS_STATUS" != "ACTIVE" ]; then
          echo "❌ EKS 클러스터가 활성 상태가 아닙니다: $EKS_STATUS"
          exit 1
        fi
        echo "✅ EKS Cluster Status: $EKS_STATUS"
    
    # ===============================================
    # ECR 로그인
    # ===============================================
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    # ===============================================
    # Docker 이미지 빌드 및 푸시
    # ===============================================
    - name: Build and push Docker image
      id: build-image
      run: |
        echo "🐳 Docker 이미지 빌드 중..."
        
        # Git 커밋 해시를 태그로 사용
        IMAGE_TAG=${{ github.sha }}
        IMAGE_URI=${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        
        # server 폴더로 이동해서 Docker 빌드
        cd server
        docker build -t $IMAGE_URI .
        docker tag $IMAGE_URI ${{ env.ECR_REPOSITORY }}:latest
        
        echo "📤 ECR에 이미지 푸시 중..."
        docker push $IMAGE_URI
        docker push ${{ env.ECR_REPOSITORY }}:latest
        
        echo "✅ 이미지 푸시 완료: $IMAGE_URI"
        echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT

    - name: Test Database Connection via Bastion
      run: |
        # AWS CLI를 사용해서 리소스 정보 직접 조회
        PROJECT_NAME="walb-app"
        
        # RDS 엔드포인트 조회 (태그 기반)
        echo "🔍 RDS 인스턴스 조회 중..."
        DB_HOST=$(aws rds describe-db-instances \
          --query "DBInstances[?contains(keys(TagList[?Key=='Project']), 'Project') && TagList[?Key=='Project'].Value[0]=='${PROJECT_NAME}'].Endpoint.Address" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$DB_HOST" ]; then
          # 태그 조회가 안 되면 DB 이름으로 조회
          DB_HOST=$(aws rds describe-db-instances \
            --query "DBInstances[?DBName=='mydb'].Endpoint.Address" \
            --output text 2>/dev/null || echo "")
        fi
        
        # Bastion Host IP 조회 (태그 기반)
        echo "🔍 Bastion Host 조회 중..."
        BASTION_IP=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${PROJECT_NAME}-bastion-host" "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].PublicIpAddress" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$BASTION_IP" ] || [ "$BASTION_IP" == "None" ]; then
          # 태그로 안 되면 보안그룹으로 조회
          BASTION_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Component,Values=Bastion" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text 2>/dev/null || echo "")
        fi
        
        # DB 사용자명과 DB 이름 (하드코딩된 값 사용)
        DB_NAME="mydb"
        DB_USER="dbadmin"
        
        # Parameter Store에서 DB 패스워드 조회
        echo "🔍 DB 패스워드 조회 중..."
        DB_PASSWORD=$(aws ssm get-parameter \
          --name "/${PROJECT_NAME}/rds/master-password" \
          --with-decryption \
          --query 'Parameter.Value' \
          --output text 2>/dev/null || echo "")
        
        # 값 검증
        if [ -z "$DB_HOST" ] || [ "$DB_HOST" == "None" ]; then
          echo "❌ RDS 엔드포인트를 찾을 수 없습니다."
          echo "사용 가능한 RDS 인스턴스:"
          aws rds describe-db-instances --query "DBInstances[*].[DBInstanceIdentifier,Endpoint.Address,DBName]" --output table
          exit 1
        fi
        
        if [ -z "$BASTION_IP" ] || [ "$BASTION_IP" == "None" ]; then
          echo "❌ Bastion Host를 찾을 수 없습니다."
          echo "실행 중인 EC2 인스턴스:"
          aws ec2 describe-instances \
            --filters "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].[InstanceId,PublicIpAddress,Tags[?Key=='Name'].Value[0]]" \
            --output table
          exit 1
        fi
        
        if [ -z "$DB_PASSWORD" ]; then
          echo "❌ DB 패스워드를 Parameter Store에서 찾을 수 없습니다."
          exit 1
        fi
        
        echo "✅ DB Host: '$DB_HOST'"
        echo "✅ Bastion IP: '$BASTION_IP'"
        echo "✅ DB User: '$DB_USER'"
        echo "✅ DB Name: '$DB_NAME'"
        
        # SSH 키를 Parameter Store에서 가져오기
        echo "🔑 SSH 키 조회 중..."
        aws ssm get-parameter \
          --name "/${PROJECT_NAME}/bastion/ssh-private-key" \
          --with-decryption \
          --query 'Parameter.Value' \
          --output text > bastion_key.pem
        chmod 600 bastion_key.pem
        
        echo "🔍 SSH 연결 테스트 중..."
        # SSH 연결 테스트 (타임아웃 설정)
        if ! ssh -i bastion_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ec2-user@$BASTION_IP "echo 'SSH connection successful'" 2>/dev/null; then
          echo "❌ SSH 연결 실패. Bastion Host 상태 확인:"
          aws ec2 describe-instances \
            --filters "Name=tag:Component,Values=Bastion" \
            --query "Reservations[*].Instances[*].[InstanceId,State.Name,PublicIpAddress,PrivateIpAddress]" \
            --output table
          exit 1
        fi
        
        echo "🔗 SSH 터널을 통한 PostgreSQL 연결 테스트 중..."
        # SSH 터널을 통한 PostgreSQL 연결 테스트
        ssh -i bastion_key.pem -o StrictHostKeyChecking=no -o ExitOnForwardFailure=yes -L 5432:$DB_HOST:5432 ec2-user@$BASTION_IP -N &
        SSH_PID=$!
        
        # 터널 설정 대기
        sleep 10
        
        # PostgreSQL 클라이언트 설치 (필요한 경우)
        if ! command -v psql &> /dev/null; then
          echo "📦 PostgreSQL 클라이언트 설치 중..."
          sudo apt-get update && sudo apt-get install -y postgresql-client
        fi
        
        # 로컬 포트를 통해 RDS 연결 테스트
        if PGPASSWORD=$DB_PASSWORD psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -c "SELECT 1;" 2>/dev/null; then
          echo "✅ 데이터베이스 연결 성공"
        else
          echo "❌ 데이터베이스 연결 실패"
          kill $SSH_PID 2>/dev/null
          rm -f bastion_key.pem
          exit 1
        fi
        
        # SSH 터널 종료 및 정리
        kill $SSH_PID 2>/dev/null
        rm -f bastion_key.pem
        
        echo "✅ 데이터베이스 연결 테스트 완료"
      env:
        PROJECT_NAME: "walb-app"
        
    # ===============================================
    # PostgreSQL 클라이언트 설치 및 스키마 적용
    # ===============================================
    - name: Apply Database Schema
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🗄️ 데이터베이스 스키마 적용 중..."
        
        # PostgreSQL 클라이언트 설치
        sudo apt-get update && sudo apt-get install -y postgresql-client
        
        # 환경 변수 설정
        PROJECT_NAME="walb-app"
        DB_HOST="${{ env.RDS_ENDPOINT }}"
        DB_NAME="mydb"
        DB_USER="dbadmin"
        
        # Bastion Host IP 조회
        BASTION_IP=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${PROJECT_NAME}-bastion-host" "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].PublicIpAddress" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$BASTION_IP" ] || [ "$BASTION_IP" == "None" ]; then
          echo "❌ Bastion Host를 찾을 수 없습니다."
          exit 1
        fi
        
        echo "🔍 연결 정보:"
        echo "  RDS 엔드포인트: $DB_HOST"
        echo "  Bastion IP: $BASTION_IP"
        echo "  DB 이름: $DB_NAME"
        echo "  DB 사용자: $DB_USER"
        
        # SSH 키를 Parameter Store에서 가져오기
        echo "🔑 SSH 키 가져오는 중..."
        aws ssm get-parameter \
          --name "/${PROJECT_NAME}/bastion/ssh-private-key" \
          --with-decryption \
          --query 'Parameter.Value' \
          --output text > bastion_key.pem
        chmod 600 bastion_key.pem
        
        # SSH 터널 생성 (백그라운드에서 실행)
        echo "🔗 SSH 터널 생성 중..."
        ssh -i bastion_key.pem \
            -o StrictHostKeyChecking=no \
            -o ExitOnForwardFailure=yes \
            -L 5432:$DB_HOST:5432 \
            ec2-user@$BASTION_IP \
            -N &
        SSH_PID=$!
        
        # 터널 설정 대기
        echo "⏳ SSH 터널 설정 대기 중..."
        sleep 15
        
        # SSH 터널 상태 확인
        if ! kill -0 $SSH_PID 2>/dev/null; then
          echo "❌ SSH 터널 생성 실패"
          rm -f bastion_key.pem
          exit 1
        fi
        
        echo "✅ SSH 터널 생성 완료"
        
        # 로컬 포트를 통해 RDS 연결 테스트
        echo "🔍 데이터베이스 연결 테스트 중..."
        if ! PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
          -h localhost \
          -p 5432 \
          -U "$DB_USER" \
          -d "$DB_NAME" \
          -c "SELECT version();" \
          -v ON_ERROR_STOP=1 >/dev/null 2>&1; then
          echo "❌ 데이터베이스 연결 실패"
          kill $SSH_PID 2>/dev/null
          rm -f bastion_key.pem
          exit 1
        fi
        
        echo "✅ 데이터베이스 연결 성공"
        
        # 기존 테이블 확인
        echo "🔍 기존 테이블 확인 중..."
        EXISTING_TABLES=$(PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
          -h localhost \
          -p 5432 \
          -U "$DB_USER" \
          -d "$DB_NAME" \
          -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('users', 'posts', 'images', 'files');" \
          -v ON_ERROR_STOP=1 | tr -d ' ')
        
        if [ "$EXISTING_TABLES" -eq "0" ]; then
          echo "📝 스키마 파일 적용 중..."
          if PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
            -h localhost \
            -p 5432 \
            -U "$DB_USER" \
            -d "$DB_NAME" \
            -f server/files/schema.sql \
            -v ON_ERROR_STOP=1; then
            echo "✅ 스키마 적용 완료"
          else
            echo "❌ 스키마 적용 실패"
            kill $SSH_PID 2>/dev/null
            rm -f bastion_key.pem
            exit 1
          fi
        else
          echo "ℹ️ 테이블이 이미 존재합니다. 스키마 적용을 건너뜁니다."
        fi
        
        # 정리 작업
        echo "🧹 정리 작업 중..."
        kill $SSH_PID 2>/dev/null
        rm -f bastion_key.pem
        
        echo "✅ 데이터베이스 스키마 작업 완료"
    
    # ===============================================
    # kubectl 설치 및 EKS 연결
    # ===============================================
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Update kubeconfig for EKS
      run: |
        echo "🔧 EKS 클러스터 kubeconfig 업데이트 중..."
        
        # EKS 클러스터 이름 조회
        EKS_CLUSTER_NAME=$(aws eks list-clusters --query 'clusters[0]' --output text 2>/dev/null || echo "walb-eks-cluster")
        
        if [ -z "$EKS_CLUSTER_NAME" ] || [ "$EKS_CLUSTER_NAME" == "None" ]; then
          echo "❌ EKS 클러스터를 찾을 수 없습니다."
          echo "사용 가능한 클러스터 목록:"
          aws eks list-clusters
          exit 1
        fi
        
        echo "✅ EKS 클러스터: $EKS_CLUSTER_NAME"
        echo "EKS_CLUSTER_NAME=$EKS_CLUSTER_NAME" >> $GITHUB_ENV
        
        # kubeconfig 업데이트
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name $EKS_CLUSTER_NAME
        
        # 클러스터 연결 테스트
        echo "🔍 클러스터 연결 테스트..."
        kubectl cluster-info
        kubectl get nodes
    
    # ===============================================
    # Kubernetes 매니페스트 파일 생성
    # ===============================================
    - name: Generate Kubernetes manifests
      run: |
        echo "📝 Kubernetes 매니페스트 생성 중..."
        
        # Namespace 생성
        cat <<EOF > namespace.yaml
        apiVersion: v1
        kind: Namespace
        metadata:
          name: ${{ env.PROJECT_NAME }}
          labels:
            name: ${{ env.PROJECT_NAME }}
        EOF
        
        # ConfigMap 생성 (환경변수)
        cat <<EOF > configmap.yaml
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: ${{ env.PROJECT_NAME }}-config
          namespace: ${{ env.PROJECT_NAME }}
        data:
          DB_HOST: "${{ env.RDS_ENDPOINT }}"
          DB_PORT: "5432"
          DB_NAME: "mydb"
          DB_USER: "dbadmin"
          AWS_REGION: "${{ secrets.AWS_REGION }}"
          AWS_S3_BUCKET: "walb-app-files"
          AWS_S3_REGION: "${{ secrets.AWS_REGION }}"
          STORAGE_TYPE: "s3"
          APP_ENV: "production"
          APP_DEBUG: "false"
          PHP_MEMORY_LIMIT: "256M"
          PHP_MAX_EXECUTION_TIME: "30"
          PHP_TIMEZONE: "Asia/Seoul"
          UPLOAD_MAX_SIZE: "10M"
          SESSION_LIFETIME: "7200"
        EOF
        
        # Secret 생성 (DB 패스워드)
        cat <<EOF > secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: ${{ env.PROJECT_NAME }}-secret
          namespace: ${{ env.PROJECT_NAME }}
        type: Opaque
        data:
          DB_PASSWORD: $(echo -n "${{ secrets.DB_PASSWORD }}" | base64)
        EOF
        
        # Deployment 생성
        cat <<EOF > deployment.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ${{ env.PROJECT_NAME }}-app
          namespace: ${{ env.PROJECT_NAME }}
          labels:
            app: ${{ env.PROJECT_NAME }}-app
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: ${{ env.PROJECT_NAME }}-app
          template:
            metadata:
              labels:
                app: ${{ env.PROJECT_NAME }}-app
            spec:
              serviceAccountName: ${{ env.PROJECT_NAME }}-service-account
              containers:
              - name: php-app
                image: ${{ steps.build-image.outputs.image }}
                ports:
                - containerPort: 80
                  name: http
                envFrom:
                - configMapRef:
                    name: ${{ env.PROJECT_NAME }}-config
                - secretRef:
                    name: ${{ env.PROJECT_NAME }}-secret
                livenessProbe:
                  httpGet:
                    path: /healthcheck.php
                    port: 80
                  initialDelaySeconds: 60
                  periodSeconds: 30
                  timeoutSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /healthcheck.php
                    port: 80
                  initialDelaySeconds: 30
                  periodSeconds: 10
                  timeoutSeconds: 5
                resources:
                  requests:
                    memory: "256Mi"
                    cpu: "250m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
                securityContext:
                  runAsNonRoot: false
                  allowPrivilegeEscalation: false
                  readOnlyRootFilesystem: false
        EOF
        
        # Service 생성
        cat <<EOF > service.yaml
        apiVersion: v1
        kind: Service
        metadata:
          name: ${{ env.PROJECT_NAME }}-service
          namespace: ${{ env.PROJECT_NAME }}
          labels:
            app: ${{ env.PROJECT_NAME }}-app
        spec:
          type: ClusterIP
          ports:
          - port: 80
            targetPort: 80
            protocol: TCP
            name: http
          selector:
            app: ${{ env.PROJECT_NAME }}-app
        EOF
        
        # ServiceAccount 생성 (IRSA용)
        cat <<EOF > serviceaccount.yaml
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: ${{ env.PROJECT_NAME }}-service-account
          namespace: ${{ env.PROJECT_NAME }}
          annotations:
            eks.amazonaws.com/role-arn: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/walb-app-eks-app-role
        EOF
        
        echo "✅ 매니페스트 파일 생성 완료"
    
    # ===============================================
    # EKS에 애플리케이션 배포 (main 브랜치일 때만)
    # ===============================================
    - name: Deploy to EKS
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🚀 EKS에 애플리케이션 배포 중..."
        
        # Namespace 먼저 생성
        kubectl apply -f namespace.yaml
        
        # 나머지 리소스 배포
        kubectl apply -f serviceaccount.yaml
        kubectl apply -f configmap.yaml
        kubectl apply -f secret.yaml
        kubectl apply -f deployment.yaml
        kubectl apply -f service.yaml
        
        echo "⏳ 배포 완료 대기 중..."
        kubectl rollout status deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --timeout=300s
    
    # ===============================================
    # 배포 결과 확인
    # ===============================================
    - name: Verify deployment
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🔍 배포 상태 확인 중..."
        
        # Pod 상태 확인
        echo "📦 Pod 상태:"
        kubectl get pods -n ${{ env.PROJECT_NAME }} -l app=${{ env.PROJECT_NAME }}-app
        
        # Service 확인
        echo "🌐 Service 상태:"
        kubectl get svc -n ${{ env.PROJECT_NAME }}
        
        # Deployment 상태 확인
        READY_REPLICAS=$(kubectl get deployment ${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} -o jsonpath='{.status.readyReplicas}')
        DESIRED_REPLICAS=$(kubectl get deployment ${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} -o jsonpath='{.spec.replicas}')
        
        echo "준비된 레플리카: $READY_REPLICAS"
        echo "원하는 레플리카: $DESIRED_REPLICAS"
        
        if [ "$READY_REPLICAS" = "$DESIRED_REPLICAS" ]; then
          echo "✅ 배포가 성공적으로 완료되었습니다!"
          
          # 애플리케이션 로그 확인
          echo "📋 애플리케이션 로그 (마지막 50줄):"
          kubectl logs -l app=${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --tail=50
          
        else
          echo "❌ 배포에 문제가 있습니다."
          echo "🔍 상세 정보:"
          kubectl describe deployment ${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }}
          echo "📋 Pod 로그:"
          kubectl logs -l app=${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --tail=100
          exit 1
        fi
    
    # ===============================================
    # LoadBalancer 설정 확인 및 접속 URL 제공
    # ===============================================
    - name: Get Application URL
      if: success() && github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🔗 애플리케이션 접속 정보 확인 중..."
        
        # ALB 정보 확인
        ALB_DNS=$(aws elbv2 describe-load-balancers --query 'LoadBalancers[?contains(LoadBalancerName, `walb-app`)].DNSName' --output text 2>/dev/null || echo "")
        
        if [ -n "$ALB_DNS" ]; then
          echo "🌐 애플리케이션 접속 URL: http://$ALB_DNS"
        else
          echo "ℹ️ LoadBalancer DNS를 찾을 수 없습니다. kubectl port-forward를 사용하세요:"
          echo "kubectl port-forward -n ${{ env.PROJECT_NAME }} svc/${{ env.PROJECT_NAME }}-service 8080:80"
        fi
    
    # ===============================================
    # 배포 완료 알림
    # ===============================================
    - name: Application Deployment Notification
      if: success() && github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🎉 PHP 애플리케이션 배포 완료!"
        echo "프로젝트: ${{ env.PROJECT_NAME }}"
        echo "이미지: ${{ steps.build-image.outputs.image }}"
        echo "클러스터: ${{ env.EKS_CLUSTER_NAME }}"
        echo "네임스페이스: ${{ env.PROJECT_NAME }}"
        echo "데이터베이스: ${{ env.RDS_ENDPOINT }}"
        echo "커밋: ${{ github.sha }}"
        echo "배포 시간: $(date)"
        
        # 배포된 서비스 정보 출력
        kubectl get all -n ${{ env.PROJECT_NAME }}

    # ===============================================
    # 배포 실패 시 롤백
    # ===============================================
    - name: Rollback on failure
      if: failure() && github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "❌ 배포 실패 - 이전 버전으로 롤백 중..."
        kubectl rollout undo deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} || true
        kubectl rollout status deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --timeout=300s || true
        echo "✅ 롤백 시도 완료"