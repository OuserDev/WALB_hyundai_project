# .github/workflows/deploy-app.yml
# PHP Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Î∞∞Ìè¨ ÏõåÌÅ¨ÌîåÎ°úÏö∞ (server Ìè¥Îçî Î≥ÄÍ≤ΩÏãúÎßå Ïã§Ìñâ)

name: Deploy PHP Application

on:
  push:
    branches: [ main, terraform ]
    paths:
      - 'WALB/server/**'
      - .github/workflows/deploy-app.yml
  pull_request:
    branches: [ main, terraform ]
    paths:
      - 'WALB/server/**'
      - .github/workflows/deploy-app.yml

env:
  PROJECT_NAME: "walb-app"
  
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    # ÏõåÌÇπ ÎîîÎ†âÌÜ†Î¶¨Î•º WALBÎ°ú ÏÑ§Ï†ï
    defaults:
      run:
        working-directory: ./WALB
    
    permissions:
      id-token: write
      contents: read
    
    steps:
    # ===============================================
    # ÏÜåÏä§ÏΩîÎìú Ï≤¥ÌÅ¨ÏïÑÏõÉ
    # ===============================================
    - name: Checkout code
      uses: actions/checkout@v4
    
    # ===============================================
    # PHP Î∞è Composer ÌôòÍ≤Ω ÏÑ§Ï†ï
    # ===============================================
    - name: Set up PHP
      uses: shivammathur/setup-php@v2
      with:
        php-version: '8.1'
        extensions: pdo, pdo_pgsql, mbstring, xml, zip, gd
        coverage: none
    
    - name: Validate Composer
      run: |
        echo "üîç PHP Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Í≤ÄÏ¶ù Ï§ë..."
        if [ -f "server/composer.json" ]; then
          cd server
          composer validate --no-check-publish
          composer install --no-dev --optimize-autoloader --no-interaction
          echo "‚úÖ Composer Í≤ÄÏ¶ù ÏôÑÎ£å"
        else
          echo "‚ÑπÔ∏è Composer ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§. Docker ÎπåÎìúÎßå Ïã§ÌñâÌï©ÎãàÎã§."
        fi
    
    # ===============================================
    # AWS Ïù∏Ï¶ù (OIDC Î∞©Ïãù)
    # ===============================================
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN_APP }}
        aws-region: ${{ secrets.AWS_REGION }}
        role-session-name: GitHubActions-Application-${{ github.run_id }}

    # ===============================================
    # Í∏∞Ï°¥ Ïù∏ÌîÑÎùº Ï†ïÎ≥¥ Ï°∞Ìöå
    # ===============================================
    - name: Get Infrastructure Resources
      run: |
        echo "üîç Í∏∞Ï°¥ Ïù∏ÌîÑÎùº Î¶¨ÏÜåÏä§ Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë..."
        
        # ECR Î¶¨Ìè¨ÏßÄÌÜ†Î¶¨ URI Ï°∞Ìöå
        ECR_REPO=$(aws ecr describe-repositories --repository-names ${PROJECT_NAME}-ecr --query 'repositories[0].repositoryUri' --output text 2>/dev/null || echo "")
        if [ -z "$ECR_REPO" ]; then
          echo "‚ùå ECR Î¶¨Ìè¨ÏßÄÌÜ†Î¶¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${PROJECT_NAME}-ecr"
          echo "Î®ºÏ†Ä Ïù∏ÌîÑÎùº Î∞∞Ìè¨Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§."
          exit 1
        fi
        echo "ECR_REPOSITORY=$ECR_REPO" >> $GITHUB_ENV
        echo "‚úÖ ECR Repository: $ECR_REPO"
        
        # EKS ÌÅ¥Îü¨Ïä§ÌÑ∞ Ïù¥Î¶Ñ Ï°∞Ìöå
        EKS_CLUSTER=$(aws eks describe-cluster --name walb-eks-cluster --query 'cluster.name' --output text 2>/dev/null || echo "")
        if [ -z "$EKS_CLUSTER" ] || [ "$EKS_CLUSTER" == "None" ]; then
          echo "‚ùå EKS ÌÅ¥Îü¨Ïä§ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${PROJECT_NAME}-eks"
          echo "Î®ºÏ†Ä Ïù∏ÌîÑÎùº Î∞∞Ìè¨Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§."
          exit 1
        fi
        echo "EKS_CLUSTER_NAME=$EKS_CLUSTER" >> $GITHUB_ENV
        echo "‚úÖ EKS Cluster: $EKS_CLUSTER"
        
        # RDS ÏóîÎìúÌè¨Ïù∏Ìä∏ Ï°∞Ìöå
        RDS_ENDPOINT=$(aws rds describe-db-instances --query 'DBInstances[?DBName==`mydb`].Endpoint.Address' --output text 2>/dev/null || echo "")
        if [ -z "$RDS_ENDPOINT" ] || [ "$RDS_ENDPOINT" == "None" ]; then
          echo "‚ùå RDS Ïù∏Ïä§ÌÑ¥Ïä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§"
          echo "Î®ºÏ†Ä Ïù∏ÌîÑÎùº Î∞∞Ìè¨Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§."
          exit 1
        fi
        echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV
        echo "‚úÖ RDS Endpoint: $RDS_ENDPOINT"
        
        # EKS ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÉÅÌÉú ÌôïÏù∏
        EKS_STATUS=$(aws eks describe-cluster --name $EKS_CLUSTER --query 'cluster.status' --output text)
        if [ "$EKS_STATUS" != "ACTIVE" ]; then
          echo "‚ùå EKS ÌÅ¥Îü¨Ïä§ÌÑ∞Í∞Ä ÌôúÏÑ± ÏÉÅÌÉúÍ∞Ä ÏïÑÎãôÎãàÎã§: $EKS_STATUS"
          exit 1
        fi
        echo "‚úÖ EKS Cluster Status: $EKS_STATUS"
    
    # ===============================================
    # ECR Î°úÍ∑∏Ïù∏
    # ===============================================
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    # ===============================================
    # Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú Î∞è Ìë∏Ïãú
    # ===============================================
    - name: Build and push Docker image
      id: build-image
      run: |
        echo "üê≥ Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú Ï§ë..."
        
        # Git Ïª§Î∞ã Ìï¥ÏãúÎ•º ÌÉúÍ∑∏Î°ú ÏÇ¨Ïö©
        IMAGE_TAG=${{ github.sha }}
        IMAGE_URI=${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        
        # server Ìè¥ÎçîÎ°ú Ïù¥ÎèôÌï¥ÏÑú Docker ÎπåÎìú
        cd server
        docker build -t $IMAGE_URI .
        docker tag $IMAGE_URI ${{ env.ECR_REPOSITORY }}:latest
        
        echo "üì§ ECRÏóê Ïù¥ÎØ∏ÏßÄ Ìë∏Ïãú Ï§ë..."
        docker push $IMAGE_URI
        docker push ${{ env.ECR_REPOSITORY }}:latest
        
        echo "‚úÖ Ïù¥ÎØ∏ÏßÄ Ìë∏Ïãú ÏôÑÎ£å: $IMAGE_URI"
        echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT

    - name: Test Database Connection via Bastion
      run: |
        # AWS CLIÎ•º ÏÇ¨Ïö©Ìï¥ÏÑú Î¶¨ÏÜåÏä§ Ï†ïÎ≥¥ ÏßÅÏ†ë Ï°∞Ìöå
        PROJECT_NAME="walb-app"
        
        # RDS ÏóîÎìúÌè¨Ïù∏Ìä∏ Ï°∞Ìöå (ÌÉúÍ∑∏ Í∏∞Î∞ò)
        echo "üîç RDS Ïù∏Ïä§ÌÑ¥Ïä§ Ï°∞Ìöå Ï§ë..."
        DB_HOST=$(aws rds describe-db-instances \
          --query "DBInstances[?contains(keys(TagList[?Key=='Project']), 'Project') && TagList[?Key=='Project'].Value[0]=='${PROJECT_NAME}'].Endpoint.Address" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$DB_HOST" ]; then
          # ÌÉúÍ∑∏ Ï°∞ÌöåÍ∞Ä Ïïà ÎêòÎ©¥ DB Ïù¥Î¶ÑÏúºÎ°ú Ï°∞Ìöå
          DB_HOST=$(aws rds describe-db-instances \
            --query "DBInstances[?DBName=='mydb'].Endpoint.Address" \
            --output text 2>/dev/null || echo "")
        fi
        
        # Bastion Host IP Ï°∞Ìöå (ÌÉúÍ∑∏ Í∏∞Î∞ò)
        echo "üîç Bastion Host Ï°∞Ìöå Ï§ë..."
        BASTION_IP=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${PROJECT_NAME}-bastion-host" "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].PublicIpAddress" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$BASTION_IP" ] || [ "$BASTION_IP" == "None" ]; then
          # ÌÉúÍ∑∏Î°ú Ïïà ÎêòÎ©¥ Î≥¥ÏïàÍ∑∏Î£πÏúºÎ°ú Ï°∞Ìöå
          BASTION_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Component,Values=Bastion" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text 2>/dev/null || echo "")
        fi
        
        # DB ÏÇ¨Ïö©ÏûêÎ™ÖÍ≥º DB Ïù¥Î¶Ñ (ÌïòÎìúÏΩîÎî©Îêú Í∞í ÏÇ¨Ïö©)
        DB_NAME="mydb"
        DB_USER="dbadmin"
        
        # Parameter StoreÏóêÏÑú DB Ìå®Ïä§ÏõåÎìú Ï°∞Ìöå
        echo "üîç DB Ìå®Ïä§ÏõåÎìú Ï°∞Ìöå Ï§ë..."
        DB_PASSWORD=$(aws ssm get-parameter \
          --name "/${PROJECT_NAME}/rds/master-password" \
          --with-decryption \
          --query 'Parameter.Value' \
          --output text 2>/dev/null || echo "")
        
        # Í∞í Í≤ÄÏ¶ù
        if [ -z "$DB_HOST" ] || [ "$DB_HOST" == "None" ]; then
          echo "‚ùå RDS ÏóîÎìúÌè¨Ïù∏Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
          echo "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú RDS Ïù∏Ïä§ÌÑ¥Ïä§:"
          aws rds describe-db-instances --query "DBInstances[*].[DBInstanceIdentifier,Endpoint.Address,DBName]" --output table
          exit 1
        fi
        
        if [ -z "$BASTION_IP" ] || [ "$BASTION_IP" == "None" ]; then
          echo "‚ùå Bastion HostÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
          echo "Ïã§Ìñâ Ï§ëÏù∏ EC2 Ïù∏Ïä§ÌÑ¥Ïä§:"
          aws ec2 describe-instances \
            --filters "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].[InstanceId,PublicIpAddress,Tags[?Key=='Name'].Value[0]]" \
            --output table
          exit 1
        fi
        
        if [ -z "$DB_PASSWORD" ]; then
          echo "‚ùå DB Ìå®Ïä§ÏõåÎìúÎ•º Parameter StoreÏóêÏÑú Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
          exit 1
        fi
        
        echo "‚úÖ DB Host: '$DB_HOST'"
        echo "‚úÖ Bastion IP: '$BASTION_IP'"
        echo "‚úÖ DB User: '$DB_USER'"
        echo "‚úÖ DB Name: '$DB_NAME'"
        
        # Î≥¥Ïïà Í∑∏Î£π ÏûêÎèô ÏÑ§Ï†ï
        echo "üîß Î≥¥Ïïà Í∑∏Î£π Í∑úÏπô ÏûêÎèô ÏÑ§Ï†ï Ï§ë..."
        
        # Bastion Host Ï†ïÎ≥¥ Ï°∞Ìöå
        BASTION_INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=ip-address,Values=$BASTION_IP" "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$BASTION_INSTANCE_ID" ] && [ "$BASTION_INSTANCE_ID" != "None" ]; then
          # Bastion HostÏùò Î≥¥Ïïà Í∑∏Î£π Ï°∞Ìöå
          BASTION_SG=$(aws ec2 describe-instances \
            --instance-ids $BASTION_INSTANCE_ID \
            --query "Reservations[0].Instances[0].SecurityGroups[0].GroupId" \
            --output text 2>/dev/null || echo "")
          
          echo "Bastion Security Group: $BASTION_SG"
        fi
        
        # RDS Ï†ïÎ≥¥ Ï°∞Ìöå
        RDS_INSTANCE_ID=$(aws rds describe-db-instances \
          --query "DBInstances[?Endpoint.Address=='$DB_HOST'].DBInstanceIdentifier" \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$RDS_INSTANCE_ID" ] && [ "$RDS_INSTANCE_ID" != "None" ]; then
          # RDSÏùò Î≥¥Ïïà Í∑∏Î£π Ï°∞Ìöå
          RDS_SG=$(aws rds describe-db-instances \
            --db-instance-identifier $RDS_INSTANCE_ID \
            --query "DBInstances[0].VpcSecurityGroups[0].VpcSecurityGroupId" \
            --output text 2>/dev/null || echo "")
          
          echo "RDS Security Group: $RDS_SG"
          
          # RDS Î≥¥Ïïà Í∑∏Î£πÏóê Bastion Ï†ëÍ∑º Í∑úÏπô Ï∂îÍ∞Ä
          if [ -n "$BASTION_SG" ] && [ -n "$RDS_SG" ]; then
            echo "üîß RDS Î≥¥Ïïà Í∑∏Î£πÏóê Bastion Ï†ëÍ∑º Í∑úÏπô Ï∂îÍ∞Ä Ï§ë..."
            
            # Í∏∞Ï°¥ Í∑úÏπô ÌôïÏù∏
            EXISTING_RULE=$(aws ec2 describe-security-groups \
              --group-ids $RDS_SG \
              --query "SecurityGroups[0].IpPermissions[?FromPort==\`5432\` && UserIdGroupPairs[?GroupId==\`$BASTION_SG\`]]" \
              --output text 2>/dev/null || echo "")
            
            if [ -z "$EXISTING_RULE" ]; then
              aws ec2 authorize-security-group-ingress \
                --group-id $RDS_SG \
                --protocol tcp \
                --port 5432 \
                --source-group $BASTION_SG \
                --no-cli-pager 2>/dev/null && echo "‚úÖ RDS Ïù∏Î∞îÏö¥Îìú Í∑úÏπô Ï∂îÍ∞Ä ÏôÑÎ£å" || echo "‚ö†Ô∏è RDS Í∑úÏπô Ï∂îÍ∞Ä Ïã§Ìå® (Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï† Ïàò ÏûàÏùå)"
            else
              echo "‚úÖ RDS Ïù∏Î∞îÏö¥Îìú Í∑úÏπôÏù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§"
            fi
          fi
        fi
        
        # Bastion Î≥¥Ïïà Í∑∏Î£πÏóê ÏïÑÏõÉÎ∞îÏö¥Îìú Í∑úÏπô ÌôïÏù∏/Ï∂îÍ∞Ä
        if [ -n "$BASTION_SG" ]; then
          echo "üîß Bastion Î≥¥Ïïà Í∑∏Î£π ÏïÑÏõÉÎ∞îÏö¥Îìú Í∑úÏπô ÌôïÏù∏ Ï§ë..."
          
          # PostgreSQL ÏïÑÏõÉÎ∞îÏö¥Îìú Í∑úÏπô ÌôïÏù∏
          EXISTING_OUTBOUND=$(aws ec2 describe-security-groups \
            --group-ids $BASTION_SG \
            --query "SecurityGroups[0].IpPermissionsEgress[?FromPort==\`5432\` || IpProtocol==\`-1\`]" \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$EXISTING_OUTBOUND" ]; then
            echo "üîß Bastion ÏïÑÏõÉÎ∞îÏö¥Îìú Í∑úÏπô Ï∂îÍ∞Ä Ï§ë..."
            aws ec2 authorize-security-group-egress \
              --group-id $BASTION_SG \
              --protocol tcp \
              --port 5432 \
              --cidr 0.0.0.0/0 \
              --no-cli-pager 2>/dev/null && echo "‚úÖ Bastion ÏïÑÏõÉÎ∞îÏö¥Îìú Í∑úÏπô Ï∂îÍ∞Ä ÏôÑÎ£å" || echo "‚ö†Ô∏è Bastion Í∑úÏπô Ï∂îÍ∞Ä Ïã§Ìå® (Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï† Ïàò ÏûàÏùå)"
          else
            echo "‚úÖ Bastion ÏïÑÏõÉÎ∞îÏö¥Îìú Í∑úÏπôÏù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§"
          fi
        fi
        
        # SSH ÌÇ§Î•º Parameter StoreÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞
        echo "üîë SSH ÌÇ§ Ï°∞Ìöå Ï§ë..."
        aws ssm get-parameter \
          --name "/${PROJECT_NAME}/bastion/ssh-private-key" \
          --with-decryption \
          --query 'Parameter.Value' \
          --output text > bastion_key.pem
        chmod 600 bastion_key.pem
        
        echo "üîç SSH Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Ï§ë..."
        # SSH Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ (ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï)
        if ! ssh -i bastion_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ec2-user@$BASTION_IP "echo 'SSH connection successful'" 2>/dev/null; then
          echo "‚ùå SSH Ïó∞Í≤∞ Ïã§Ìå®. Bastion Host ÏÉÅÌÉú ÌôïÏù∏:"
          aws ec2 describe-instances \
            --filters "Name=tag:Component,Values=Bastion" \
            --query "Reservations[*].Instances[*].[InstanceId,State.Name,PublicIpAddress,PrivateIpAddress]" \
            --output table
          exit 1
        fi
        
        echo "üîó SSH ÌÑ∞ÎÑêÏùÑ ÌÜµÌïú PostgreSQL Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Ï§ë..."
        
        # PostgreSQL ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ïπò (Î®ºÏ†Ä ÏÑ§Ïπò)
        if ! command -v psql &> /dev/null; then
          echo "üì¶ PostgreSQL ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ïπò Ï§ë..."
          sudo apt-get update -qq && sudo apt-get install -y postgresql-client
        fi
        
        # Î°úÏª¨ Ìè¨Ìä∏Í∞Ä ÏÇ¨Ïö© Ï§ëÏù∏ÏßÄ ÌôïÏù∏
        if netstat -tuln | grep -q ":5432 "; then
          echo "‚ö†Ô∏è Ìè¨Ìä∏ 5432Í∞Ä Ïù¥ÎØ∏ ÏÇ¨Ïö© Ï§ëÏûÖÎãàÎã§. Îã§Î•∏ Ìè¨Ìä∏Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§."
          LOCAL_PORT=5433
        else
          LOCAL_PORT=5432
        fi
        
        echo "üîó SSH ÌÑ∞ÎÑê ÏÉùÏÑ± Ï§ë... (Î°úÏª¨ Ìè¨Ìä∏: $LOCAL_PORT)"
        # SSH ÌÑ∞ÎÑê ÏÉùÏÑ± with Îçî ÎßéÏùÄ ÏòµÏÖò
        ssh -i bastion_key.pem \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ExitOnForwardFailure=yes \
            -o ServerAliveInterval=60 \
            -o ServerAliveCountMax=3 \
            -o ConnectTimeout=30 \
            -L $LOCAL_PORT:$DB_HOST:5432 \
            ec2-user@$BASTION_IP \
            -N &
        SSH_PID=$!
        
        # SSH ÌÑ∞ÎÑêÏù¥ Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        echo "‚è≥ SSH ÌÑ∞ÎÑê ÏÑ§Ï†ï ÌôïÏù∏ Ï§ë..."
        sleep 5
        
        # SSH ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä ÏïÑÏßÅ Ïã§Ìñâ Ï§ëÏù∏ÏßÄ ÌôïÏù∏
        if ! kill -0 $SSH_PID 2>/dev/null; then
          echo "‚ùå SSH ÌÑ∞ÎÑê ÏÉùÏÑ± Ïã§Ìå®"
          echo "SSH Ïó∞Í≤∞ Î°úÍ∑∏ ÌôïÏù∏:"
          ssh -i bastion_key.pem -o StrictHostKeyChecking=no ec2-user@$BASTION_IP "echo 'SSH Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ ÏÑ±Í≥µ'" || echo "SSH Í∏∞Î≥∏ Ïó∞Í≤∞ Ïã§Ìå®"
          rm -f bastion_key.pem
          exit 1
        fi
        
        # ÌÑ∞ÎÑê Ìè¨Ìä∏Í∞Ä Ïó¥Î†∏ÎäîÏßÄ ÌôïÏù∏
        echo "üîç ÌÑ∞ÎÑê Ìè¨Ìä∏ ÌôïÏù∏ Ï§ë..."
        for i in {1..30}; do
          if netstat -tuln | grep -q ":$LOCAL_PORT "; then
            echo "‚úÖ SSH ÌÑ∞ÎÑêÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§ (Ìè¨Ìä∏: $LOCAL_PORT)"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "‚ùå SSH ÌÑ∞ÎÑê Ìè¨Ìä∏ ÏÑ§Ï†ï ÏãúÍ∞Ñ Ï¥àÍ≥º"
            kill $SSH_PID 2>/dev/null
            rm -f bastion_key.pem
            exit 1
          fi
          sleep 2
        done
        
        # Bastion HostÏóêÏÑú ÏßÅÏ†ë DB Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
        echo "üîç Bastion HostÏóêÏÑú DB ÏßÅÏ†ë Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Ï§ë..."
        ssh -i bastion_key.pem -o StrictHostKeyChecking=no ec2-user@$BASTION_IP "
          # PostgreSQL ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ïπò ÌôïÏù∏
          if ! command -v psql &> /dev/null; then
            echo 'üì¶ BastionÏóê PostgreSQL ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ïπò Ï§ë...'
            sudo yum update -y
            sudo yum install -y postgresql15
          fi
          
          # DB Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
          echo 'üîç BastionÏóêÏÑú RDS ÏßÅÏ†ë Ïó∞Í≤∞ ÌÖåÏä§Ìä∏...'
          if PGPASSWORD='$DB_PASSWORD' psql -h $DB_HOST -p 5432 -U $DB_USER -d $DB_NAME -c 'SELECT version();' 2>/dev/null; then
            echo '‚úÖ BastionÏóêÏÑú RDS ÏßÅÏ†ë Ïó∞Í≤∞ ÏÑ±Í≥µ'
          else
            echo '‚ùå BastionÏóêÏÑú RDS ÏßÅÏ†ë Ïó∞Í≤∞ Ïã§Ìå®'
            echo 'üîç ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ ÌôïÏù∏:'
            telnet $DB_HOST 5432 < /dev/null 2>&1 | head -5
            echo 'üîç Î≥¥Ïïà Í∑∏Î£π ÌôïÏù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.'
            exit 1
          fi
        "
        
        # ÌÑ∞ÎÑêÏùÑ ÌÜµÌïú Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ (Ïû¨ÏãúÎèÑ Î°úÏßÅ Ï∂îÍ∞Ä)
        echo "üîç SSH ÌÑ∞ÎÑêÏùÑ ÌÜµÌïú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Ï§ë..."
        DB_CONNECTED=false
        for i in {1..5}; do
          if PGPASSWORD=$DB_PASSWORD psql -h localhost -p $LOCAL_PORT -U $DB_USER -d $DB_NAME -c "SELECT 1;" 2>/dev/null; then
            echo "‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏÑ±Í≥µ (ÏãúÎèÑ $i/5)"
            DB_CONNECTED=true
            break
          else
            echo "‚ö†Ô∏è Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå® (ÏãúÎèÑ $i/5)"
            # ÏûêÏÑ∏Ìïú Ïò§Î•ò Ï†ïÎ≥¥ Ï∂úÎ†•
            echo "üîç ÏÉÅÏÑ∏ Ïò§Î•ò Ï†ïÎ≥¥:"
            PGPASSWORD=$DB_PASSWORD psql -h localhost -p $LOCAL_PORT -U $DB_USER -d $DB_NAME -c "SELECT 1;" 2>&1 || true
            
            if [ $i -lt 5 ]; then
              echo "3Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ..."
              sleep 3
            fi
          fi
        done
        
        if [ "$DB_CONNECTED" != "true" ]; then
          echo "‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏµúÏ¢Ö Ïã§Ìå®"
          echo "üîç Ïó∞Í≤∞ Ï†ïÎ≥¥ ÌôïÏù∏:"
          echo "  Î°úÏª¨ Ìè¨Ìä∏: $LOCAL_PORT"
          echo "  DB Ìò∏Ïä§Ìä∏: $DB_HOST"
          echo "  DB ÏÇ¨Ïö©Ïûê: $DB_USER"
          echo "  DB Ïù¥Î¶Ñ: $DB_NAME"
          echo "üîç ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÉÅÌÉú:"
          netstat -tuln | grep ":$LOCAL_PORT"
          echo "üîç SSH ÌÑ∞ÎÑê ÏÉÅÌÉú:"
          ps aux | grep ssh | grep $BASTION_IP || echo "SSH ÌîÑÎ°úÏÑ∏Ïä§ ÏóÜÏùå"
          kill $SSH_PID 2>/dev/null
          rm -f bastion_key.pem
          exit 1
        fi
        
        # SSH ÌÑ∞ÎÑê Ï¢ÖÎ£å Î∞è Ï†ïÎ¶¨
        echo "üßπ SSH ÌÑ∞ÎÑê Ï†ïÎ¶¨ Ï§ë..."
        kill $SSH_PID 2>/dev/null
        rm -f bastion_key.pem
        
        echo "‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ ÏôÑÎ£å"
      env:
        PROJECT_NAME: "walb-app"
        
    # ===============================================
    # PostgreSQL ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ïπò Î∞è Ïä§ÌÇ§Îßà Ï†ÅÏö©
    # ===============================================
    - name: Apply Database Schema
      if: ${{ github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/terraform') }}
      run: |
        echo "üóÑÔ∏è Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà Ï†ÅÏö© Ï§ë..."
        
        # PostgreSQL ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ïπò
        sudo apt-get update && sudo apt-get install -y postgresql-client
        
        # ÌôòÍ≤Ω Î≥ÄÏàò ÏÑ§Ï†ï
        PROJECT_NAME="walb-app"
        DB_HOST="${{ env.RDS_ENDPOINT }}"
        DB_NAME="mydb"
        DB_USER="dbadmin"
        
        # Bastion Host IP Ï°∞Ìöå
        BASTION_IP=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${PROJECT_NAME}-bastion-host" "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].PublicIpAddress" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$BASTION_IP" ] || [ "$BASTION_IP" == "None" ]; then
          echo "‚ùå Bastion HostÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
          exit 1
        fi
        
        echo "üîç Ïó∞Í≤∞ Ï†ïÎ≥¥:"
        echo "  RDS ÏóîÎìúÌè¨Ïù∏Ìä∏: $DB_HOST"
        echo "  Bastion IP: $BASTION_IP"
        echo "  DB Ïù¥Î¶Ñ: $DB_NAME"
        echo "  DB ÏÇ¨Ïö©Ïûê: $DB_USER"
        
        # Î≥¥Ïïà Í∑∏Î£π ÏûêÎèô ÏÑ§Ï†ï
        echo "üîß Î≥¥Ïïà Í∑∏Î£π Í∑úÏπô ÏûêÎèô ÏÑ§Ï†ï Ï§ë..."
        
        # Bastion Host Ï†ïÎ≥¥ Ï°∞Ìöå
        BASTION_INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=ip-address,Values=$BASTION_IP" "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$BASTION_INSTANCE_ID" ] && [ "$BASTION_INSTANCE_ID" != "None" ]; then
          # Bastion HostÏùò Î≥¥Ïïà Í∑∏Î£π Ï°∞Ìöå
          BASTION_SG=$(aws ec2 describe-instances \
            --instance-ids $BASTION_INSTANCE_ID \
            --query "Reservations[0].Instances[0].SecurityGroups[0].GroupId" \
            --output text 2>/dev/null || echo "")
          
          echo "Bastion Security Group: $BASTION_SG"
        fi
        
        # RDS Ï†ïÎ≥¥ Ï°∞Ìöå
        RDS_INSTANCE_ID=$(aws rds describe-db-instances \
          --query "DBInstances[?Endpoint.Address=='$DB_HOST'].DBInstanceIdentifier" \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$RDS_INSTANCE_ID" ] && [ "$RDS_INSTANCE_ID" != "None" ]; then
          # RDSÏùò Î≥¥Ïïà Í∑∏Î£π Ï°∞Ìöå
          RDS_SG=$(aws rds describe-db-instances \
            --db-instance-identifier $RDS_INSTANCE_ID \
            --query "DBInstances[0].VpcSecurityGroups[0].VpcSecurityGroupId" \
            --output text 2>/dev/null || echo "")
          
          echo "RDS Security Group: $RDS_SG"
          
          # RDS Î≥¥Ïïà Í∑∏Î£πÏóê Bastion Ï†ëÍ∑º Í∑úÏπô Ï∂îÍ∞Ä
          if [ -n "$BASTION_SG" ] && [ -n "$RDS_SG" ]; then
            echo "üîß RDS Î≥¥Ïïà Í∑∏Î£πÏóê Bastion Ï†ëÍ∑º Í∑úÏπô Ï∂îÍ∞Ä Ï§ë..."
            
            aws ec2 authorize-security-group-ingress \
              --group-id $RDS_SG \
              --protocol tcp \
              --port 5432 \
              --source-group $BASTION_SG \
              --no-cli-pager 2>/dev/null && echo "‚úÖ RDS Ïù∏Î∞îÏö¥Îìú Í∑úÏπô Ï∂îÍ∞Ä ÏôÑÎ£å" || echo "‚úÖ RDS Í∑úÏπôÏù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§"
          fi
        fi
        
        # Bastion Î≥¥Ïïà Í∑∏Î£πÏóê ÏïÑÏõÉÎ∞îÏö¥Îìú Í∑úÏπô Ï∂îÍ∞Ä
        if [ -n "$BASTION_SG" ]; then
          echo "üîß Bastion Î≥¥Ïïà Í∑∏Î£π ÏïÑÏõÉÎ∞îÏö¥Îìú Í∑úÏπô Ï∂îÍ∞Ä Ï§ë..."
          
          aws ec2 authorize-security-group-egress \
            --group-id $BASTION_SG \
            --protocol tcp \
            --port 5432 \
            --cidr 0.0.0.0/0 \
            --no-cli-pager 2>/dev/null && echo "‚úÖ Bastion ÏïÑÏõÉÎ∞îÏö¥Îìú Í∑úÏπô Ï∂îÍ∞Ä ÏôÑÎ£å" || echo "‚úÖ Bastion Í∑úÏπôÏù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§"
        fi
        
        # SSH ÌÇ§Î•º Parameter StoreÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞
        echo "üîë SSH ÌÇ§ Í∞ÄÏ†∏Ïò§Îäî Ï§ë..."
        aws ssm get-parameter \
          --name "/${PROJECT_NAME}/bastion/ssh-private-key" \
          --with-decryption \
          --query 'Parameter.Value' \
          --output text > bastion_key.pem
        chmod 600 bastion_key.pem
        
        # Î°úÏª¨ Ìè¨Ìä∏Í∞Ä ÏÇ¨Ïö© Ï§ëÏù∏ÏßÄ ÌôïÏù∏
        if netstat -tuln | grep -q ":5432 "; then
          echo "‚ö†Ô∏è Ìè¨Ìä∏ 5432Í∞Ä Ïù¥ÎØ∏ ÏÇ¨Ïö© Ï§ëÏûÖÎãàÎã§. Îã§Î•∏ Ìè¨Ìä∏Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§."
          LOCAL_PORT=5433
        else
          LOCAL_PORT=5432
        fi
        
        # SSH ÌÑ∞ÎÑê ÏÉùÏÑ± (Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Ïã§Ìñâ)
        echo "üîó SSH ÌÑ∞ÎÑê ÏÉùÏÑ± Ï§ë... (Î°úÏª¨ Ìè¨Ìä∏: $LOCAL_PORT)"
        ssh -i bastion_key.pem \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ExitOnForwardFailure=yes \
            -o ServerAliveInterval=60 \
            -o ServerAliveCountMax=3 \
            -o ConnectTimeout=30 \
            -L $LOCAL_PORT:$DB_HOST:5432 \
            ec2-user@$BASTION_IP \
            -N &
        SSH_PID=$!
        
        # ÌÑ∞ÎÑê ÏÑ§Ï†ï ÎåÄÍ∏∞ Î∞è ÌôïÏù∏
        echo "‚è≥ SSH ÌÑ∞ÎÑê ÏÑ§Ï†ï ÌôïÏù∏ Ï§ë..."
        sleep 5
        
        # SSH ÌÑ∞ÎÑê ÏÉÅÌÉú ÌôïÏù∏
        if ! kill -0 $SSH_PID 2>/dev/null; then
          echo "‚ùå SSH ÌÑ∞ÎÑê ÏÉùÏÑ± Ïã§Ìå®"
          echo "SSH Ïó∞Í≤∞ Î°úÍ∑∏ ÌôïÏù∏:"
          ssh -i bastion_key.pem -o StrictHostKeyChecking=no ec2-user@$BASTION_IP "echo 'SSH Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ ÏÑ±Í≥µ'" || echo "SSH Í∏∞Î≥∏ Ïó∞Í≤∞ Ïã§Ìå®"
          rm -f bastion_key.pem
          exit 1
        fi
        
        # ÌÑ∞ÎÑê Ìè¨Ìä∏Í∞Ä Ïó¥Î†∏ÎäîÏßÄ ÌôïÏù∏
        echo "üîç ÌÑ∞ÎÑê Ìè¨Ìä∏ ÌôïÏù∏ Ï§ë..."
        for i in {1..30}; do
          if netstat -tuln | grep -q ":$LOCAL_PORT "; then
            echo "‚úÖ SSH ÌÑ∞ÎÑêÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§ (Ìè¨Ìä∏: $LOCAL_PORT)"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "‚ùå SSH ÌÑ∞ÎÑê Ìè¨Ìä∏ ÏÑ§Ï†ï ÏãúÍ∞Ñ Ï¥àÍ≥º"
            kill $SSH_PID 2>/dev/null
            rm -f bastion_key.pem
            exit 1
          fi
          sleep 2
        done
        
        echo "‚úÖ SSH ÌÑ∞ÎÑê ÏÉùÏÑ± ÏôÑÎ£å"
        
        # Bastion HostÏóêÏÑú ÏßÅÏ†ë DB Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
        echo "üîç Bastion HostÏóêÏÑú DB ÏßÅÏ†ë Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Ï§ë..."
        ssh -i bastion_key.pem -o StrictHostKeyChecking=no ec2-user@$BASTION_IP "
          # PostgreSQL ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ïπò ÌôïÏù∏
          if ! command -v psql &> /dev/null; then
            echo 'üì¶ BastionÏóê PostgreSQL ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ïπò Ï§ë...'
            sudo yum update -y
            sudo yum install -y postgresql15
          fi
          
          # DB Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
          echo 'üîç BastionÏóêÏÑú RDS ÏßÅÏ†ë Ïó∞Í≤∞ ÌÖåÏä§Ìä∏...'
          if PGPASSWORD='${{ secrets.DB_PASSWORD }}' psql -h $DB_HOST -p 5432 -U $DB_USER -d $DB_NAME -c 'SELECT version();' 2>/dev/null; then
            echo '‚úÖ BastionÏóêÏÑú RDS ÏßÅÏ†ë Ïó∞Í≤∞ ÏÑ±Í≥µ'
          else
            echo '‚ùå BastionÏóêÏÑú RDS ÏßÅÏ†ë Ïó∞Í≤∞ Ïã§Ìå®'
            echo 'üîç ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ ÌôïÏù∏:'
            nc -zv $DB_HOST 5432 2>&1 || telnet $DB_HOST 5432 < /dev/null 2>&1 | head -5
            echo 'üîç Î≥¥Ïïà Í∑∏Î£π ÌôïÏù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.'
            exit 1
          fi
        "
        
        # Î°úÏª¨ Ìè¨Ìä∏Î•º ÌÜµÌï¥ RDS Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ (Ïû¨ÏãúÎèÑ Î°úÏßÅ)
        echo "üîç SSH ÌÑ∞ÎÑêÏùÑ ÌÜµÌïú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Ï§ë..."
        DB_CONNECTED=false
        for i in {1..5}; do
          if PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
            -h localhost \
            -p $LOCAL_PORT \
            -U "$DB_USER" \
            -d "$DB_NAME" \
            -c "SELECT version();" \
            -v ON_ERROR_STOP=1 2>/dev/null; then
            echo "‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏÑ±Í≥µ (ÏãúÎèÑ $i/5)"
            DB_CONNECTED=true
            break
          else
            echo "‚ö†Ô∏è Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå® (ÏãúÎèÑ $i/5)"
            # ÏûêÏÑ∏Ìïú Ïò§Î•ò Ï†ïÎ≥¥ Ï∂úÎ†•
            echo "üîç ÏÉÅÏÑ∏ Ïò§Î•ò Ï†ïÎ≥¥:"
            PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
              -h localhost \
              -p $LOCAL_PORT \
              -U "$DB_USER" \
              -d "$DB_NAME" \
              -c "SELECT version();" 2>&1 || true
            
            if [ $i -lt 5 ]; then
              echo "3Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ..."
              sleep 3
            fi
          fi
        done
        
        if [ "$DB_CONNECTED" != "true" ]; then
          echo "‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏµúÏ¢Ö Ïã§Ìå®"
          echo "üîç Ïó∞Í≤∞ Ï†ïÎ≥¥:"
          echo "  Î°úÏª¨ Ìè¨Ìä∏: $LOCAL_PORT"
          echo "  DB Ìò∏Ïä§Ìä∏: $DB_HOST"
          echo "  DB ÏÇ¨Ïö©Ïûê: $DB_USER"
          echo "  DB Ïù¥Î¶Ñ: $DB_NAME"
          kill $SSH_PID 2>/dev/null
          rm -f bastion_key.pem
          exit 1
        fi
        
        # Í∏∞Ï°¥ ÌÖåÏù¥Î∏î ÌôïÏù∏
        echo "üîç Í∏∞Ï°¥ ÌÖåÏù¥Î∏î ÌôïÏù∏ Ï§ë..."
        EXISTING_TABLES=$(PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
          -h localhost \
          -p $LOCAL_PORT \
          -U "$DB_USER" \
          -d "$DB_NAME" \
          -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('users', 'posts', 'images', 'files');" \
          -v ON_ERROR_STOP=1 | tr -d ' ')
        
        echo "üìä Í∏∞Ï°¥ ÌÖåÏù¥Î∏î Í∞úÏàò: $EXISTING_TABLES/4"
        
        if [ "$EXISTING_TABLES" -lt "4" ]; then
          echo "üìù Ïä§ÌÇ§Îßà ÌååÏùº Ï†ÅÏö© Ï§ë..."
          if PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
            -h localhost \
            -p $LOCAL_PORT \
            -U "$DB_USER" \
            -d "$DB_NAME" \
            -f server/files/schema.sql \
            -v ON_ERROR_STOP=1; then
            echo "‚úÖ Ïä§ÌÇ§Îßà Ï†ÅÏö© ÏôÑÎ£å"
          else
            echo "‚ùå Ïä§ÌÇ§Îßà Ï†ÅÏö© Ïã§Ìå®"
            kill $SSH_PID 2>/dev/null
            rm -f bastion_key.pem
            exit 1
          fi

        else
          echo "‚ÑπÔ∏è Î™®Îì† ÌÖåÏù¥Î∏îÏù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§ ($EXISTING_TABLES/4). Ïä§ÌÇ§Îßà Ï†ÅÏö©ÏùÑ Í±¥ÎÑàÎúÅÎãàÎã§."
        fi

        # Ï†ïÎ¶¨ ÏûëÏóÖ
        echo "üßπ Ï†ïÎ¶¨ ÏûëÏóÖ Ï§ë..."
        kill $SSH_PID 2>/dev/null
        rm -f bastion_key.pem

        echo "‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà ÏûëÏóÖ ÏôÑÎ£å"

    # ===============================================
    # kubectl Î∞è Helm ÏÑ§Ïπò
    # ===============================================
    - name: Install kubectl and Helm
      run: |
          echo "üîß kubectl Î∞è Helm ÏÑ§Ïπò Ï§ë..."

          # kubectl ÏÑ§Ïπò
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

          # Helm ÏÑ§Ïπò
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

          echo "‚úÖ kubectl Î∞è Helm ÏÑ§Ïπò ÏôÑÎ£å"
          kubectl version --client
          helm version

    - name: Update kubeconfig for EKS
      run: |
          echo "üîß EKS ÌÅ¥Îü¨Ïä§ÌÑ∞ kubeconfig ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë..."

          # ÌòÑÏû¨ AWS ÏûêÍ≤© Ï¶ùÎ™Ö ÌôïÏù∏
          echo "üîç ÌòÑÏû¨ AWS ÏûêÍ≤© Ï¶ùÎ™Ö ÌôïÏù∏..."
          aws sts get-caller-identity

          # EKS ÌÅ¥Îü¨Ïä§ÌÑ∞ Ïù¥Î¶Ñ Ï°∞Ìöå (Ïó¨Îü¨ Î∞©Î≤ï ÏãúÎèÑ)
          echo "üîç EKS ÌÅ¥Îü¨Ïä§ÌÑ∞ Ï°∞Ìöå Ï§ë..."

          # Î∞©Î≤ï 1: ÌÅ¥Îü¨Ïä§ÌÑ∞ Î™©Î°ùÏóêÏÑú Ï≤´ Î≤àÏß∏ Ï°∞Ìöå
          EKS_CLUSTER_NAME=$(aws eks list-clusters --query 'clusters[0]' --output text 2>/dev/null || echo "")

          # Î∞©Î≤ï 2: ÌäπÏ†ï Ïù¥Î¶ÑÏúºÎ°ú Ï°∞Ìöå
          if [ -z "$EKS_CLUSTER_NAME" ] || [ "$EKS_CLUSTER_NAME" == "None" ]; then
            EKS_CLUSTER_NAME="walb-eks-cluster"
            echo "Í∏∞Î≥∏ ÌÅ¥Îü¨Ïä§ÌÑ∞ Ïù¥Î¶Ñ ÏÇ¨Ïö©: $EKS_CLUSTER_NAME"
          fi

          # ÌÅ¥Îü¨Ïä§ÌÑ∞ Ï°¥Ïû¨ ÌôïÏù∏
          if ! aws eks describe-cluster --name "$EKS_CLUSTER_NAME" --region ${{ secrets.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚ùå EKS ÌÅ¥Îü¨Ïä§ÌÑ∞ '$EKS_CLUSTER_NAME'Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            echo "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÌÅ¥Îü¨Ïä§ÌÑ∞ Î™©Î°ù:"
            aws eks list-clusters --region ${{ secrets.AWS_REGION }}
            exit 1
          fi

          echo "‚úÖ EKS ÌÅ¥Îü¨Ïä§ÌÑ∞: $EKS_CLUSTER_NAME"
          echo "EKS_CLUSTER_NAME=$EKS_CLUSTER_NAME" >> $GITHUB_ENV

          # ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÉÅÌÉú ÌôïÏù∏
          CLUSTER_STATUS=$(aws eks describe-cluster --name "$EKS_CLUSTER_NAME" --region ${{ secrets.AWS_REGION }} --query 'cluster.status' --output text)
          echo "ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÉÅÌÉú: $CLUSTER_STATUS"

          if [ "$CLUSTER_STATUS" != "ACTIVE" ]; then
            echo "‚ùå ÌÅ¥Îü¨Ïä§ÌÑ∞Í∞Ä ACTIVE ÏÉÅÌÉúÍ∞Ä ÏïÑÎãôÎãàÎã§: $CLUSTER_STATUS"
            exit 1
          fi

          # IAM Ïó≠Ìï†Í≥º OIDC Í≥µÍ∏âÏûê Ï†ïÎ≥¥ ÌôïÏù∏
          echo "üîç IAM Ïó≠Ìï†Í≥º OIDC ÏÑ§Ï†ï ÌôïÏù∏ Ï§ë..."
          CLUSTER_OIDC_ISSUER=$(aws eks describe-cluster --name "$EKS_CLUSTER_NAME" --region ${{ secrets.AWS_REGION }} --query 'cluster.identity.oidc.issuer' --output text)
          echo "OIDC Î∞úÌñâÏûê: $CLUSTER_OIDC_ISSUER"
          
          # kubeconfig ÏóÖÎç∞Ïù¥Ìä∏ (ÌòÑÏû¨ OIDC ÏûêÍ≤© Ï¶ùÎ™Ö ÏÇ¨Ïö©)
          echo "üîß kubeconfig ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë (OIDC ÏûêÍ≤© Ï¶ùÎ™Ö ÏÇ¨Ïö©)..."
          aws eks update-kubeconfig \
            --region ${{ secrets.AWS_REGION }} \
            --name "$EKS_CLUSTER_NAME" \
            --verbose

          # AWS ÏûêÍ≤© Ï¶ùÎ™Ö ÌôïÏù∏
          echo "üîç ÌòÑÏû¨ AWS ÏûêÍ≤© Ï¶ùÎ™Ö ÌôïÏù∏..."
          aws sts get-caller-identity
          
          # ÌÅ¥Îü¨Ïä§ÌÑ∞ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ (ÏûêÏÑ∏Ìïú Ïò§Î•ò Ï†ïÎ≥¥ Ìè¨Ìï®)
          echo "üîç ÌÅ¥Îü¨Ïä§ÌÑ∞ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏..."
          if ! kubectl cluster-info --request-timeout=30s; then
            echo "‚ùå kubectl cluster-info Ïã§Ìå®. Ï∂îÍ∞Ä ÏßÑÎã® Ï†ïÎ≥¥:"
            
            # kubectl ÏÑ§Ï†ï ÌôïÏù∏
            echo "kubectl ÏÑ§Ï†ï ÌôïÏù∏:"
            kubectl config view --minify
            
            # ÌòÑÏû¨ Ïª®ÌÖçÏä§Ìä∏ ÌôïÏù∏
            echo "ÌòÑÏû¨ Ïª®ÌÖçÏä§Ìä∏:"
            kubectl config current-context
            
            # ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏßÅÏ†ë ÌÖåÏä§Ìä∏
            CLUSTER_ENDPOINT=$(aws eks describe-cluster --name "$EKS_CLUSTER_NAME" --region ${{ secrets.AWS_REGION }} --query 'cluster.endpoint' --output text)
            echo "ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏóîÎìúÌè¨Ïù∏Ìä∏: $CLUSTER_ENDPOINT"
            
            # aws-auth ConfigMap ÌôïÏù∏ Î∞è GitHub Actions Ïó≠Ìï† Ï∂îÍ∞Ä
            echo "üîç aws-auth ConfigMap ÌôïÏù∏ Î∞è GitHub Actions Ïó≠Ìï† Ï∂îÍ∞Ä..."
            
            # ÌòÑÏû¨ aws-auth ConfigMap Î∞±ÏóÖ
            kubectl get configmap aws-auth -n kube-system -o yaml > aws-auth-backup.yaml 2>/dev/null || echo "Í∏∞Ï°¥ aws-auth ConfigMap ÏóÜÏùå"
            
            # GitHub Actions OIDC Ïó≠Ìï†ÏùÑ aws-authÏóê Ï∂îÍ∞Ä
            GITHUB_ROLE_ARN="arn:aws:iam::253157413163:role/walb-github"
            
            # aws-auth ConfigMap YAML ÌååÏùº ÏÉùÏÑ±
            echo "apiVersion: v1" > aws-auth-temp.yaml
            echo "kind: ConfigMap" >> aws-auth-temp.yaml
            echo "metadata:" >> aws-auth-temp.yaml
            echo "  name: aws-auth" >> aws-auth-temp.yaml
            echo "  namespace: kube-system" >> aws-auth-temp.yaml
            echo "data:" >> aws-auth-temp.yaml
            echo "  mapRoles: |" >> aws-auth-temp.yaml
            echo "    - rolearn: arn:aws:iam::253157413163:role/walb-github" >> aws-auth-temp.yaml
            echo "      username: github-actions" >> aws-auth-temp.yaml
            echo "      groups:" >> aws-auth-temp.yaml
            echo "        - system:masters" >> aws-auth-temp.yaml
            echo "    - rolearn: arn:aws:iam::253157413163:role/walb-eks-cluster-eks-node-group-role" >> aws-auth-temp.yaml
            echo "      username: system:node:{{EC2PrivateDNSName}}" >> aws-auth-temp.yaml
            echo "      groups:" >> aws-auth-temp.yaml
            echo "        - system:bootstrappers" >> aws-auth-temp.yaml
            echo "        - system:nodes" >> aws-auth-temp.yaml
            
            # ÏûÑÏãú ÌååÏùºÎ°ú kubectl apply Ïã§Ìñâ
            kubectl apply -f aws-auth-temp.yaml
            rm -f aws-auth-temp.yaml
            
            echo "‚úÖ GitHub Actions Ïó≠Ìï†ÏùÑ aws-auth ConfigMapÏóê Ï∂îÍ∞Ä"
            
            # Ïû†Ïãú ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ
            echo "‚è≥ ÏÑ§Ï†ï Ï†ÅÏö© ÎåÄÍ∏∞ Ï§ë..."
            sleep 10
            
            exit 1
          fi

          # GitHub Actions Ïó≠Ìï†Ïù¥ aws-authÏóê Îì±Î°ùÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
          echo "üîç aws-auth ConfigMapÏóêÏÑú GitHub Actions Ïó≠Ìï† ÌôïÏù∏..."
          GITHUB_ROLE_ARN="arn:aws:iam::253157413163:role/walb-github"
          
          if ! kubectl get configmap aws-auth -n kube-system -o yaml | grep -q "$GITHUB_ROLE_ARN"; then
            echo "‚ö†Ô∏è GitHub Actions Ïó≠Ìï†Ïù¥ aws-authÏóê ÏóÜÏäµÎãàÎã§. Ï∂îÍ∞Ä Ï§ë..."
            
            # ÌòÑÏû¨ aws-auth ConfigMap Î∞±ÏóÖ
            kubectl get configmap aws-auth -n kube-system -o yaml > aws-auth-backup.yaml
            
            # GitHub Actions OIDC Ïó≠Ìï†ÏùÑ aws-authÏóê Ï∂îÍ∞Ä
            # aws-auth ConfigMap YAML ÌååÏùº ÏÉùÏÑ±
            echo "apiVersion: v1" > aws-auth-temp2.yaml
            echo "kind: ConfigMap" >> aws-auth-temp2.yaml
            echo "metadata:" >> aws-auth-temp2.yaml
            echo "  name: aws-auth" >> aws-auth-temp2.yaml
            echo "  namespace: kube-system" >> aws-auth-temp2.yaml
            echo "data:" >> aws-auth-temp2.yaml
            echo "  mapRoles: |" >> aws-auth-temp2.yaml
            echo "    - rolearn: arn:aws:iam::253157413163:role/walb-github" >> aws-auth-temp2.yaml
            echo "      username: github-actions" >> aws-auth-temp2.yaml
            echo "      groups:" >> aws-auth-temp2.yaml
            echo "        - system:masters" >> aws-auth-temp2.yaml
            echo "    - rolearn: arn:aws:iam::253157413163:role/walb-eks-cluster-eks-node-group-role" >> aws-auth-temp2.yaml
            echo "      username: system:node:{{EC2PrivateDNSName}}" >> aws-auth-temp2.yaml
            echo "      groups:" >> aws-auth-temp2.yaml
            echo "        - system:bootstrappers" >> aws-auth-temp2.yaml
            echo "        - system:nodes" >> aws-auth-temp2.yaml
            
            # ÏûÑÏãú ÌååÏùºÎ°ú kubectl apply Ïã§Ìñâ
            kubectl apply -f aws-auth-temp2.yaml
            rm -f aws-auth-temp2.yaml
            
            echo "‚úÖ GitHub Actions Ïó≠Ìï†ÏùÑ aws-auth ConfigMapÏóê Ï∂îÍ∞Ä ÏôÑÎ£å"
          else
            echo "‚úÖ GitHub Actions Ïó≠Ìï†Ïù¥ Ïù¥ÎØ∏ aws-authÏóê Îì±Î°ùÎêòÏñ¥ ÏûàÏäµÎãàÎã§"
          fi

          echo "üîç ÎÖ∏Îìú ÏÉÅÌÉú ÌôïÏù∏..."
          kubectl get nodes --show-labels

      # ===============================================
      # AWS Load Balancer Controller ÌôïÏù∏
      # ===============================================
    - name: Check AWS Load Balancer Controller
      run: |
          echo "üîç AWS Load Balancer Controller ÏÉÅÌÉú ÌôïÏù∏ Ï§ë..."
          
          # AWS Load Balancer Controller Pod ÌôïÏù∏
          if kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller >/dev/null 2>&1; then
            echo "‚úÖ AWS Load Balancer Controller Pod Î∞úÍ≤¨"
            kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller
          else
            echo "‚ùå AWS Load Balancer ControllerÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            echo "TerraformÏúºÎ°ú AWS Load Balancer ControllerÎ•º Î®ºÏ†Ä ÏÑ§ÏπòÌï¥Ï£ºÏÑ∏Ïöî."
            exit 1
          fi
          
          # IngressClass ÌôïÏù∏
          if kubectl get ingressclass alb >/dev/null 2>&1; then
            echo "‚úÖ IngressClass 'alb' ÌôïÏù∏Îê®"
            kubectl get ingressclass alb
          else
            echo "‚ùå IngressClass 'alb'Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            echo "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú IngressClass:"
            kubectl get ingressclass
            exit 1
          fi
          
          # ValidatingAdmissionWebhook ÌôïÏù∏
          if kubectl get validatingwebhookconfigurations | grep -E "(vingress|aws-load-balancer)" >/dev/null 2>&1; then
            echo "‚úÖ ValidatingWebhookConfiguration ÌôïÏù∏Îê®"
            kubectl get validatingwebhookconfigurations | grep -E "(vingress|aws-load-balancer)"
          else
            echo "‚ö†Ô∏è ValidatingWebhookConfigurationÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            echo "AWS Load Balancer ControllerÍ∞Ä ÏïÑÏßÅ ÏôÑÏ†ÑÌûà Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÏùÑ Ïàò ÏûàÏäµÎãàÎã§."
          fi
          
          echo "‚úÖ AWS Load Balancer Controller ÌôïÏù∏ ÏôÑÎ£å - Ingress Í∏∞Î∞ò ALB ÏÉùÏÑ± Ï§ÄÎπÑÎê®"

      # ===============================================
      # Kubernetes Îß§ÎãàÌéòÏä§Ìä∏ ÌååÏùº ÏÉùÏÑ±
      # ===============================================
    - name: Generate Kubernetes manifests
      run: |
          echo "üìù Kubernetes Îß§ÎãàÌéòÏä§Ìä∏ ÏÉùÏÑ± Ï§ë..."

          # Namespace ÏÉùÏÑ±
          cat <<EOF > namespace.yaml
          apiVersion: v1
          kind: Namespace
          metadata:
            name: ${{ env.PROJECT_NAME }}
          EOF
          
          # ConfigMap ÏÉùÏÑ± (ÌôòÍ≤ΩÎ≥ÄÏàò)
          cat <<EOF > configmap.yaml
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: ${{ env.PROJECT_NAME }}-config
            namespace: ${{ env.PROJECT_NAME }}
          data:
            DB_HOST: "${{ env.RDS_ENDPOINT }}"
            DB_PORT: "5432"
            DB_NAME: "mydb"
            DB_USER: "dbadmin"
            AWS_REGION: "${{ secrets.AWS_REGION }}"
            AWS_S3_BUCKET: "walb-app-files"
            AWS_S3_REGION: "${{ secrets.AWS_REGION }}"
            STORAGE_TYPE: "s3"
            APP_ENV: "production"
            APP_DEBUG: "false"
            PHP_MEMORY_LIMIT: "256M"
            PHP_MAX_EXECUTION_TIME: "30"
            PHP_TIMEZONE: "Asia/Seoul"
            UPLOAD_MAX_SIZE: "10M"
            SESSION_LIFETIME: "7200"
          EOF
        
          # Secret ÏÉùÏÑ± (DB Ìå®Ïä§ÏõåÎìú)
          cat <<EOF > secret.yaml
          apiVersion: v1
          kind: Secret
          metadata:
            name: ${{ env.PROJECT_NAME }}-secret
            namespace: ${{ env.PROJECT_NAME }}
          type: Opaque
          data:
            DB_PASSWORD: $(echo -n "${{ secrets.DB_PASSWORD }}" | base64)
          EOF
          
          # Deployment ÏÉùÏÑ±
          cat <<EOF > deployment.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.PROJECT_NAME }}-app
            namespace: ${{ env.PROJECT_NAME }}
            labels:
              app: ${{ env.PROJECT_NAME }}-app
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ env.PROJECT_NAME }}-app
            template:
              metadata:
                labels:
                  app: ${{ env.PROJECT_NAME }}-app
              spec:
                serviceAccountName: ${{ env.PROJECT_NAME }}-service-account
                containers:
                - name: php-app
                  image: ${{ steps.build-image.outputs.image }}
                  ports:
                  - containerPort: 80
                    name: http
                  envFrom:
                  - configMapRef:
                      name: ${{ env.PROJECT_NAME }}-config
                  - secretRef:
                      name: ${{ env.PROJECT_NAME }}-secret
                  livenessProbe:
                    httpGet:
                      path: /healthcheck.php
                      port: 80
                    initialDelaySeconds: 60
                    periodSeconds: 30
                    timeoutSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /healthcheck.php
                      port: 80
                    initialDelaySeconds: 30
                    periodSeconds: 10
                    timeoutSeconds: 5
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  securityContext:
                    runAsNonRoot: false
                    allowPrivilegeEscalation: false
                    readOnlyRootFilesystem: false
          EOF

          # Service ÏÉùÏÑ± (Ingress Í∏∞Î∞òÏù¥ÎØÄÎ°ú ClusterIP ÏÇ¨Ïö©)
          cat <<EOF > service.yaml
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.PROJECT_NAME }}-service
            namespace: ${{ env.PROJECT_NAME }}
            labels:
              app: ${{ env.PROJECT_NAME }}-app
          spec:
            type: ClusterIP
            ports:
            - port: 80
              targetPort: 80
              protocol: TCP
              name: http
            selector:
              app: ${{ env.PROJECT_NAME }}-app
          EOF

          # Ingress ÏÉùÏÑ± (AWS Load Balancer Controller ÏÇ¨Ïö©)
          cat <<EOF > ingress.yaml
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ env.PROJECT_NAME }}-ingress
            namespace: ${{ env.PROJECT_NAME }}
            annotations:
              # AWS Application Load Balancer ÏÑ§Ï†ï
              kubernetes.io/ingress.class: alb
              alb.ingress.kubernetes.io/scheme: internet-facing
              alb.ingress.kubernetes.io/target-type: ip
              alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}]'
              alb.ingress.kubernetes.io/subnets: subnet-039b420c65ca59f58,subnet-0ed371078691c84cf
              
              # Health Check ÏÑ§Ï†ï (PHP Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò)
              alb.ingress.kubernetes.io/healthcheck-path: /healthcheck.php
              alb.ingress.kubernetes.io/healthcheck-interval-seconds: '30'
              alb.ingress.kubernetes.io/healthcheck-timeout-seconds: '10'
              alb.ingress.kubernetes.io/healthy-threshold-count: '2'
              alb.ingress.kubernetes.io/unhealthy-threshold-count: '3'
              alb.ingress.kubernetes.io/healthcheck-protocol: HTTP
              alb.ingress.kubernetes.io/healthcheck-port: '80'
              
              # Load Balancer ÏÑ§Ï†ï
              alb.ingress.kubernetes.io/load-balancer-name: ${{ env.PROJECT_NAME }}-ingress-alb
              alb.ingress.kubernetes.io/target-group-attributes: "stickiness.enabled=false,deregistration_delay.timeout_seconds=60,load_balancing.algorithm.type=round_robin,slow_start.duration_seconds=30"
          spec:
            ingressClassName: alb
            rules:
            - http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: ${{ env.PROJECT_NAME }}-service
                      port:
                        number: 80
          EOF

          echo "‚úÖ Ingress Í∏∞Î∞ò Îß§ÎãàÌéòÏä§Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å"

          # ServiceAccount ÏÉùÏÑ± (IRSAÏö©)
          cat <<EOF > serviceaccount.yaml
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: ${{ env.PROJECT_NAME }}-service-account
            namespace: ${{ env.PROJECT_NAME }}
            annotations:
              eks.amazonaws.com/role-arn: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/walb-app-eks-app-role
          EOF

          echo "‚úÖ Îß§ÎãàÌéòÏä§Ìä∏ ÌååÏùº ÏÉùÏÑ± ÏôÑÎ£å"

      # ===============================================
      # EKSÏóê Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Î∞∞Ìè¨ (main ÎòêÎäî terraform Î∏åÎûúÏπòÏùº ÎïåÎßå)
      # ===============================================
    - name: Deploy to EKS
      if: ${{ github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/terraform') }}
      run: |
          echo "üöÄ EKSÏóê Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Î∞∞Ìè¨ Ï§ë..."

          # Namespace Î®ºÏ†Ä ÏÉùÏÑ±
          kubectl apply -f namespace.yaml

          # ÎÇòÎ®∏ÏßÄ Î¶¨ÏÜåÏä§ Î∞∞Ìè¨
          kubectl apply -f serviceaccount.yaml
          kubectl apply -f configmap.yaml
          kubectl apply -f secret.yaml
          kubectl apply -f deployment.yaml
          kubectl apply -f service.yaml

          # Ingress Î∞∞Ìè¨ (AWS Load Balancer ControllerÎ°ú ALB ÏÉùÏÑ±)
          echo "üîó Ingress Î¶¨ÏÜåÏä§ Î∞∞Ìè¨ Ï§ë..."
          
          # Ingress Î∞∞Ìè¨
          echo "üöÄ Ingress Î∞∞Ìè¨ ÏãúÏûë..."
          if kubectl apply -f ingress.yaml; then
            echo "‚úÖ Ingress Î¶¨ÏÜåÏä§ ÏÉùÏÑ± ÏÑ±Í≥µ"
            
            # ALB ÏÉùÏÑ± ÎåÄÍ∏∞
            echo "‚è≥ AWS Load Balancer ControllerÏóê ÏùòÌïú ALB ÏÉùÏÑ± ÎåÄÍ∏∞ Ï§ë..."
            ALB_CREATED=false
            for i in {1..25}; do
              ALB_DNS=$(kubectl get ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
              if [ -n "$ALB_DNS" ]; then
                echo "‚úÖ ALB ÏÉùÏÑ± ÏôÑÎ£å: $ALB_DNS"
                echo "ALB_HOSTNAME=$ALB_DNS" >> $GITHUB_ENV
                echo "DEPLOYMENT_METHOD=Ingress" >> $GITHUB_ENV
                ALB_CREATED=true
                break
              fi
              
              # ÏßÑÌñâ ÏÉÅÌô© ÌôïÏù∏
              if [ $((i % 5)) -eq 0 ]; then
                echo "üîç Ingress ÏÉÅÌÉú ÌôïÏù∏ (${i}/25)..."
                kubectl get ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }} || true
                kubectl describe ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }} | grep -E "(Events|Address)" || true
              fi
              
              echo "ALB ÏÉùÏÑ± ÎåÄÍ∏∞ Ï§ë... ($i/25)"
              sleep 20
            done
            
            if [ "$ALB_CREATED" != "true" ]; then
              echo "‚ö†Ô∏è ALB ÏÉùÏÑ± ÏãúÍ∞Ñ Ï¥àÍ≥º - ÏÉÅÏÑ∏ ÏßÑÎã® Ïã§Ìñâ"
              
              echo "üîç Ingress ÏÉÅÏÑ∏ ÏÉÅÌÉú:"
              kubectl get ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }} -o yaml || true
              kubectl describe ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }} || true
              
              echo "üîç AWS Load Balancer Controller Î°úÍ∑∏:"
              kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller --tail=100 || true
              
              echo "DEPLOYMENT_METHOD=Ingress-Pending" >> $GITHUB_ENV
              echo "ALB_HOSTNAME=pending" >> $GITHUB_ENV
            fi
            
          else
            echo "‚ùå Ingress Î∞∞Ìè¨ Ïã§Ìå®"
            echo "üîç ÏßÑÎã® Ï†ïÎ≥¥:"
            kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller
            kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller --tail=50 || true
            kubectl get validatingwebhookconfigurations | grep -E "(vingress|aws-load-balancer)" || echo "ÏõπÌõÖ ÏóÜÏùå"
            kubectl get ingressclass || true
            exit 1
          fi
          
          echo "‚úÖ Ingress Í∏∞Î∞ò ALB Î∞∞Ìè¨ ÏôÑÎ£å"

          echo "‚è≥ Î∞∞Ìè¨ ÏôÑÎ£å ÎåÄÍ∏∞ Ï§ë..."
          kubectl rollout status deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --timeout=300s

      # ===============================================
      # Î∞∞Ìè¨ Í≤∞Í≥º ÌôïÏù∏
      # ===============================================
    - name: Verify Deployment
      if: ${{ github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/terraform') }}
      run: |
          echo "üîç Î∞∞Ìè¨ ÏÉÅÌÉú ÌôïÏù∏ Ï§ë..."
          echo "ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§: ${{ env.PROJECT_NAME }}"
          echo "Ïï± ÎùºÎ≤®: ${{ env.PROJECT_NAME }}-app"

          # ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Ï°¥Ïû¨ ÌôïÏù∏
          if ! kubectl get namespace ${{ env.PROJECT_NAME }} >/dev/null 2>&1; then
            echo "‚ùå ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ '${{ env.PROJECT_NAME }}'Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§."
            kubectl get namespaces
            exit 1
          fi

          # Í∏∞Î≥∏ Î¶¨ÏÜåÏä§ ÏÉÅÌÉú ÌôïÏù∏
          echo "üìã Pod ÏÉÅÌÉú:"
          kubectl get pods -n ${{ env.PROJECT_NAME }} -o wide || echo "PodÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."

          echo "üìã Service ÏÉÅÌÉú:"
          kubectl get services -n ${{ env.PROJECT_NAME }} || echo "ServiceÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."

          echo "üìã Deployment ÏÉÅÌÉú:"
          kubectl get deployments -n ${{ env.PROJECT_NAME }} || echo "DeploymentÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."

          echo "üìã Ingress ÏÉÅÌÉú:"
          kubectl get ingress -n ${{ env.PROJECT_NAME }} || echo "IngressÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."

          echo "üìã AWS Load Balancer Controller ÏÉÅÌÉú:"
          kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller || echo "AWS Load Balancer ControllerÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."

          # Deployment Ï°¥Ïû¨ ÌôïÏù∏ ÌõÑ ÎåÄÍ∏∞
          if kubectl get deployment ${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} >/dev/null 2>&1; then
            echo "‚è≥ Pod Ï§ÄÎπÑ ÏÉÅÌÉú ÎåÄÍ∏∞ Ï§ë..."
            kubectl wait --for=condition=ready pod -l app=${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --timeout=300s || echo "Pod Ï§ÄÎπÑ ÏÉÅÌÉú ÎåÄÍ∏∞ ÏãúÍ∞Ñ Ï¥àÍ≥º"
            
            echo "üìù Deployment ÏÉÅÏÑ∏ Ï†ïÎ≥¥:"
            kubectl describe deployment ${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }}
            
          else
            echo "‚ùå Deployment '${{ env.PROJECT_NAME }}-app'Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            echo "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Deployment Î™©Î°ù:"
            kubectl get deployments -n ${{ env.PROJECT_NAME }}
            exit 1
          fi

      # ===============================================
      # Î∞∞Ìè¨ Î∞©Î≤ïÎ≥Ñ Ï†ëÏÜç URL Ï†úÍ≥µ
      # ===============================================
    - name: Get Application URL
      if: success() && ${{ github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/terraform') }}
      run: |
          echo "üîó Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï†ëÏÜç Ï†ïÎ≥¥ ÌôïÏù∏ Ï§ë..."
          echo "Î∞∞Ìè¨ Î∞©Î≤ï: ${DEPLOYMENT_METHOD:-Unknown}"

          if [ "${DEPLOYMENT_METHOD:-}" = "Ingress" ]; then
            echo "üîó IngressÎ°ú Î∞∞Ìè¨Îê®"
            echo "üåê Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï†ëÏÜç URL: http://${ALB_HOSTNAME:-ÌôïÏù∏Î∂àÍ∞Ä}"
            
            echo "üîç Ingress ÏÉÅÌÉú:"
            kubectl describe ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }}
            
          elif [ "${DEPLOYMENT_METHOD:-}" = "Ingress-Pending" ]; then
            echo "‚ö†Ô∏è Ingress ALB ÏÉùÏÑ±Ïù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§"
            echo "üîç ÌòÑÏû¨ Ingress ÏÉÅÌÉú:"
            kubectl get ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }}
            kubectl describe ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }}
            
            echo "üîç AWS Load Balancer Controller Î°úÍ∑∏:"
            kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller --tail=20 || true
            
            echo "Ïû†Ïãú ÌõÑ ALBÍ∞Ä ÏÉùÏÑ±ÎêòÎ©¥ Îã§Ïùå Î™ÖÎ†πÏñ¥Î°ú URLÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî:"
            echo "kubectl get ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }}"
            
          else
            echo "‚ùì Î∞∞Ìè¨ Î∞©Î≤ïÏùÑ ÌôïÏù∏Ìï† Ïàò ÏóÜÏäµÎãàÎã§."
            echo "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏÑúÎπÑÏä§ ÌôïÏù∏:"
            kubectl get services -n ${{ env.PROJECT_NAME }}
            echo "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ingress ÌôïÏù∏:"
            kubectl get ingress -n ${{ env.PROJECT_NAME }}
          fi

          # Í≥µÌÜµ ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥
          echo ""
          echo "üìã Ï†ÑÏ≤¥ Î¶¨ÏÜåÏä§ ÏÉÅÌÉú:"
          kubectl get all -n ${{ env.PROJECT_NAME }}

      # ===============================================
      # Î∞∞Ìè¨ ÏôÑÎ£å ÏïåÎ¶º
      # ===============================================
    - name: Application Deployment Notification
      if: success() && ${{ github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/terraform') }}
      run: |
          echo "üéâ PHP Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Î∞∞Ìè¨ ÏôÑÎ£å!"
          echo "ÌîÑÎ°úÏ†ùÌä∏: ${{ env.PROJECT_NAME }}"
          echo "Ïù¥ÎØ∏ÏßÄ: ${{ steps.build-image.outputs.image }}"
          echo "ÌÅ¥Îü¨Ïä§ÌÑ∞: ${{ env.EKS_CLUSTER_NAME }}"
          echo "ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§: ${{ env.PROJECT_NAME }}"
          echo "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§: ${{ env.RDS_ENDPOINT }}"
          echo "Ïª§Î∞ã: ${{ github.sha }}"
          echo "Î∞∞Ìè¨ ÏãúÍ∞Ñ: $(date)"

          # Î∞∞Ìè¨Îêú ÏÑúÎπÑÏä§ Ï†ïÎ≥¥ Ï∂úÎ†•
          echo "üìã Î∞∞Ìè¨Îêú Î¶¨ÏÜåÏä§ Î™©Î°ù:"
          kubectl get all -n ${{ env.PROJECT_NAME }} || echo "Î¶¨ÏÜåÏä§ Ï°∞Ìöå Ïã§Ìå®"

      # ===============================================
      # Î∞∞Ìè¨ Ïã§Ìå® Ïãú Î°§Î∞±
      # ===============================================
    - name: Rollback on failure
      if: failure() && ${{ github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/terraform') }}
      run: |
          echo "‚ùå Î∞∞Ìè¨ Ïã§Ìå® - Ïù¥Ï†Ñ Î≤ÑÏ†ÑÏúºÎ°ú Î°§Î∞± Ï§ë..."
          kubectl rollout undo deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} || true
          kubectl rollout status deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --timeout=300s || true
          echo "‚úÖ Î°§Î∞± ÏãúÎèÑ ÏôÑÎ£å"
