# .github/workflows/deploy-app.yml
# PHP 애플리케이션 배포 워크플로우 (server 폴더 변경시만 실행)

name: Deploy PHP Application

on:
  push:
    branches: [ main ]
    paths:
      - 'WALB/server/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'WALB/server/**'

env:
  PROJECT_NAME: "walb-app"
  
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    # 워킹 디렉토리를 WALB로 설정
    defaults:
      run:
        working-directory: ./WALB
    
    permissions:
      id-token: write
      contents: read
    
    steps:
    # ===============================================
    # 소스코드 체크아웃
    # ===============================================
    - name: Checkout code
      uses: actions/checkout@v4
    
    # ===============================================
    # PHP 및 Composer 환경 설정
    # ===============================================
    - name: Set up PHP
      uses: shivammathur/setup-php@v2
      with:
        php-version: '8.1'
        extensions: pdo, pdo_pgsql, mbstring, xml, zip, gd
        coverage: none
    
    - name: Validate Composer
      run: |
        echo "🔍 PHP 애플리케이션 검증 중..."
        if [ -f "server/composer.json" ]; then
          cd server
          composer validate --no-check-publish
          composer install --no-dev --optimize-autoloader --no-interaction
          echo "✅ Composer 검증 완료"
        else
          echo "ℹ️ Composer 파일이 없습니다. Docker 빌드만 실행합니다."
        fi
    
    # ===============================================
    # AWS 인증 (OIDC 방식)
    # ===============================================
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN_APP }}
        aws-region: ${{ secrets.AWS_REGION }}
        role-session-name: GitHubActions-Application-${{ github.run_id }}

    # ===============================================
    # 기존 인프라 정보 조회
    # ===============================================
    - name: Get Infrastructure Resources
      run: |
        echo "🔍 기존 인프라 리소스 정보 조회 중..."
        
        # ECR 리포지토리 URI 조회
        ECR_REPO=$(aws ecr describe-repositories --repository-names ${PROJECT_NAME}-ecr --query 'repositories[0].repositoryUri' --output text 2>/dev/null || echo "")
        if [ -z "$ECR_REPO" ]; then
          echo "❌ ECR 리포지토리를 찾을 수 없습니다: ${PROJECT_NAME}-ecr"
          echo "먼저 인프라 배포가 필요합니다."
          exit 1
        fi
        echo "ECR_REPOSITORY=$ECR_REPO" >> $GITHUB_ENV
        echo "✅ ECR Repository: $ECR_REPO"
        
        # EKS 클러스터 이름 조회
        EKS_CLUSTER=$(aws eks describe-cluster --name walb-eks-cluster --query 'cluster.name' --output text 2>/dev/null || echo "")
        if [ -z "$EKS_CLUSTER" ] || [ "$EKS_CLUSTER" == "None" ]; then
          echo "❌ EKS 클러스터를 찾을 수 없습니다: ${PROJECT_NAME}-eks"
          echo "먼저 인프라 배포가 필요합니다."
          exit 1
        fi
        echo "EKS_CLUSTER_NAME=$EKS_CLUSTER" >> $GITHUB_ENV
        echo "✅ EKS Cluster: $EKS_CLUSTER"
        
        # RDS 엔드포인트 조회
        RDS_ENDPOINT=$(aws rds describe-db-instances --query 'DBInstances[?DBName==`mydb`].Endpoint.Address' --output text 2>/dev/null || echo "")
        if [ -z "$RDS_ENDPOINT" ] || [ "$RDS_ENDPOINT" == "None" ]; then
          echo "❌ RDS 인스턴스를 찾을 수 없습니다"
          echo "먼저 인프라 배포가 필요합니다."
          exit 1
        fi
        echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV
        echo "✅ RDS Endpoint: $RDS_ENDPOINT"
        
        # EKS 클러스터 상태 확인
        EKS_STATUS=$(aws eks describe-cluster --name $EKS_CLUSTER --query 'cluster.status' --output text)
        if [ "$EKS_STATUS" != "ACTIVE" ]; then
          echo "❌ EKS 클러스터가 활성 상태가 아닙니다: $EKS_STATUS"
          exit 1
        fi
        echo "✅ EKS Cluster Status: $EKS_STATUS"
    
    # ===============================================
    # ECR 로그인
    # ===============================================
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    # ===============================================
    # Docker 이미지 빌드 및 푸시
    # ===============================================
    - name: Build and push Docker image
      id: build-image
      run: |
        echo "🐳 Docker 이미지 빌드 중..."
        
        # Git 커밋 해시를 태그로 사용
        IMAGE_TAG=${{ github.sha }}
        IMAGE_URI=${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        
        # server 폴더로 이동해서 Docker 빌드
        cd server
        docker build -t $IMAGE_URI .
        docker tag $IMAGE_URI ${{ env.ECR_REPOSITORY }}:latest
        
        echo "📤 ECR에 이미지 푸시 중..."
        docker push $IMAGE_URI
        docker push ${{ env.ECR_REPOSITORY }}:latest
        
        echo "✅ 이미지 푸시 완료: $IMAGE_URI"
        echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT

    # Terraform 설치
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.9.0"
        terraform_wrapper: false

    # 데이터베이스 테스트 단계
    - name: Test Database Connection via Bastion
      run: |
        # PostgreSQL 클라이언트 설치
        sudo apt-get update && sudo apt-get install -y postgresql-client
        
        # Terraform outputs에서 DB 정보 가져오기
        cd infrastructure/terraform
        
        DB_HOST=$(terraform output -raw rds_endpoint)
        DB_NAME=$(terraform output -raw db_name)
        DB_USER=$(terraform output -raw db_username)
        BASTION_IP=$(terraform output -raw bastion_public_ip)
        DB_PASSWORD=$(aws ssm get-parameter --name "/${PROJECT_NAME}/rds/master-password" --with-decryption --query 'Parameter.Value' --output text)

        # SSH 키를 Parameter Store에서 가져오기
        aws ssm get-parameter --name "/${PROJECT_NAME}/bastion/ssh-private-key" --with-decryption --query 'Parameter.Value' --output text > bastion_key.pem
        chmod 600 bastion_key.pem

        echo "DB Host: $DB_HOST"
        echo "Bastion IP: $BASTION_IP"
        
        # SSH 연결 테스트 먼저 수행
        ssh -i bastion_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ec2-user@$BASTION_IP "echo 'SSH connection successful'"
        
        # SSH 터널을 백그라운드에서 실행
        ssh -i bastion_key.pem -o StrictHostKeyChecking=no -o ExitOnForwardFailure=yes -f -N -L 5432:$DB_HOST:5432 ec2-user@$BASTION_IP
        
        # 터널이 설정될 때까지 대기
        sleep 15
        
        # 포트가 열려있는지 확인
        nc -z localhost 5432 || (echo "SSH 터널 설정 실패"; exit 1)
        
        # 로컬 포트를 통해 RDS 연결 테스트
        PGPASSWORD=$DB_PASSWORD psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -c "SELECT 1;" -v ON_ERROR_STOP=1
        
        # SSH 터널 종료 및 정리
        pkill -f "ssh.*5432:$DB_HOST:5432" || true
        rm -f bastion_key.pem
      env:
        PROJECT_NAME: "walb-app"
        
    # ===============================================
    # PostgreSQL 클라이언트 설치 및 스키마 적용
    # ===============================================
    - name: Apply Database Schema
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🗄️ 데이터베이스 스키마 적용 중..."
        
        # PostgreSQL 클라이언트 설치
        sudo apt-get update && sudo apt-get install -y postgresql-client
        
        # 스키마 적용
        echo "RDS 엔드포인트: ${{ env.RDS_ENDPOINT }}"
        
        # 연결 테스트
        PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
          -h "${{ env.RDS_ENDPOINT }}" \
          -p 5432 \
          -U dbadmin \
          -d mydb \
          -c "SELECT version();" \
          -v ON_ERROR_STOP=1
        
        # 기존 테이블 확인
        EXISTING_TABLES=$(PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
          -h "${{ env.RDS_ENDPOINT }}" \
          -p 5432 \
          -U dbadmin \
          -d mydb \
          -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('users', 'posts', 'images', 'files');" \
          -v ON_ERROR_STOP=1 | tr -d ' ')
        
        if [ "$EXISTING_TABLES" -eq "0" ]; then
          echo "📝 스키마 파일 적용 중..."
          PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
            -h "${{ env.RDS_ENDPOINT }}" \
            -p 5432 \
            -U dbadmin \
            -d mydb \
            -f server/files/schema.sql \
            -v ON_ERROR_STOP=1
          echo "✅ 스키마 적용 완료"
        else
          echo "ℹ️ 테이블이 이미 존재합니다. 스키마 적용을 건너뜁니다."
        fi
        
        # 테이블 목록 확인
        echo "📋 생성된 테이블 목록:"
        PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
          -h "${{ env.RDS_ENDPOINT }}" \
          -p 5432 \
          -U dbadmin \
          -d mydb \
          -c "\dt" \
          -v ON_ERROR_STOP=1
    
    # ===============================================
    # kubectl 설치 및 EKS 연결
    # ===============================================
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Update kubeconfig for EKS
      run: |
        echo "🔧 EKS 클러스터 kubeconfig 업데이트 중..."
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        
        # 클러스터 연결 테스트
        echo "🔍 클러스터 연결 테스트..."
        kubectl cluster-info
        kubectl get nodes
    
    # ===============================================
    # Kubernetes 매니페스트 파일 생성
    # ===============================================
    - name: Generate Kubernetes manifests
      run: |
        echo "📝 Kubernetes 매니페스트 생성 중..."
        
        # Namespace 생성
        cat <<EOF > namespace.yaml
        apiVersion: v1
        kind: Namespace
        metadata:
          name: ${{ env.PROJECT_NAME }}
          labels:
            name: ${{ env.PROJECT_NAME }}
        EOF
        
        # ConfigMap 생성 (환경변수)
        cat <<EOF > configmap.yaml
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: ${{ env.PROJECT_NAME }}-config
          namespace: ${{ env.PROJECT_NAME }}
        data:
          DB_HOST: "${{ env.RDS_ENDPOINT }}"
          DB_PORT: "5432"
          DB_NAME: "mydb"
          DB_USER: "dbadmin"
          AWS_REGION: "${{ secrets.AWS_REGION }}"
          AWS_S3_BUCKET: "walb-app-files"
          AWS_S3_REGION: "${{ secrets.AWS_REGION }}"
          STORAGE_TYPE: "s3"
          APP_ENV: "production"
          APP_DEBUG: "false"
          PHP_MEMORY_LIMIT: "256M"
          PHP_MAX_EXECUTION_TIME: "30"
          PHP_TIMEZONE: "Asia/Seoul"
          UPLOAD_MAX_SIZE: "10M"
          SESSION_LIFETIME: "7200"
        EOF
        
        # Secret 생성 (DB 패스워드)
        cat <<EOF > secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: ${{ env.PROJECT_NAME }}-secret
          namespace: ${{ env.PROJECT_NAME }}
        type: Opaque
        data:
          DB_PASSWORD: $(echo -n "${{ secrets.DB_PASSWORD }}" | base64)
        EOF
        
        # Deployment 생성
        cat <<EOF > deployment.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ${{ env.PROJECT_NAME }}-app
          namespace: ${{ env.PROJECT_NAME }}
          labels:
            app: ${{ env.PROJECT_NAME }}-app
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: ${{ env.PROJECT_NAME }}-app
          template:
            metadata:
              labels:
                app: ${{ env.PROJECT_NAME }}-app
            spec:
              serviceAccountName: ${{ env.PROJECT_NAME }}-service-account
              containers:
              - name: php-app
                image: ${{ steps.build-image.outputs.image }}
                ports:
                - containerPort: 80
                  name: http
                envFrom:
                - configMapRef:
                    name: ${{ env.PROJECT_NAME }}-config
                - secretRef:
                    name: ${{ env.PROJECT_NAME }}-secret
                livenessProbe:
                  httpGet:
                    path: /healthcheck.php
                    port: 80
                  initialDelaySeconds: 60
                  periodSeconds: 30
                  timeoutSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /healthcheck.php
                    port: 80
                  initialDelaySeconds: 30
                  periodSeconds: 10
                  timeoutSeconds: 5
                resources:
                  requests:
                    memory: "256Mi"
                    cpu: "250m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
                securityContext:
                  runAsNonRoot: false
                  allowPrivilegeEscalation: false
                  readOnlyRootFilesystem: false
        EOF
        
        # Service 생성
        cat <<EOF > service.yaml
        apiVersion: v1
        kind: Service
        metadata:
          name: ${{ env.PROJECT_NAME }}-service
          namespace: ${{ env.PROJECT_NAME }}
          labels:
            app: ${{ env.PROJECT_NAME }}-app
        spec:
          type: ClusterIP
          ports:
          - port: 80
            targetPort: 80
            protocol: TCP
            name: http
          selector:
            app: ${{ env.PROJECT_NAME }}-app
        EOF
        
        # ServiceAccount 생성 (IRSA용)
        cat <<EOF > serviceaccount.yaml
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: ${{ env.PROJECT_NAME }}-service-account
          namespace: ${{ env.PROJECT_NAME }}
          annotations:
            eks.amazonaws.com/role-arn: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/walb-app-eks-app-role
        EOF
        
        echo "✅ 매니페스트 파일 생성 완료"
    
    # ===============================================
    # EKS에 애플리케이션 배포 (main 브랜치일 때만)
    # ===============================================
    - name: Deploy to EKS
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🚀 EKS에 애플리케이션 배포 중..."
        
        # Namespace 먼저 생성
        kubectl apply -f namespace.yaml
        
        # 나머지 리소스 배포
        kubectl apply -f serviceaccount.yaml
        kubectl apply -f configmap.yaml
        kubectl apply -f secret.yaml
        kubectl apply -f deployment.yaml
        kubectl apply -f service.yaml
        
        echo "⏳ 배포 완료 대기 중..."
        kubectl rollout status deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --timeout=300s
    
    # ===============================================
    # 배포 결과 확인
    # ===============================================
    - name: Verify deployment
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🔍 배포 상태 확인 중..."
        
        # Pod 상태 확인
        echo "📦 Pod 상태:"
        kubectl get pods -n ${{ env.PROJECT_NAME }} -l app=${{ env.PROJECT_NAME }}-app
        
        # Service 확인
        echo "🌐 Service 상태:"
        kubectl get svc -n ${{ env.PROJECT_NAME }}
        
        # Deployment 상태 확인
        READY_REPLICAS=$(kubectl get deployment ${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} -o jsonpath='{.status.readyReplicas}')
        DESIRED_REPLICAS=$(kubectl get deployment ${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} -o jsonpath='{.spec.replicas}')
        
        echo "준비된 레플리카: $READY_REPLICAS"
        echo "원하는 레플리카: $DESIRED_REPLICAS"
        
        if [ "$READY_REPLICAS" = "$DESIRED_REPLICAS" ]; then
          echo "✅ 배포가 성공적으로 완료되었습니다!"
          
          # 애플리케이션 로그 확인
          echo "📋 애플리케이션 로그 (마지막 50줄):"
          kubectl logs -l app=${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --tail=50
          
        else
          echo "❌ 배포에 문제가 있습니다."
          echo "🔍 상세 정보:"
          kubectl describe deployment ${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }}
          echo "📋 Pod 로그:"
          kubectl logs -l app=${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --tail=100
          exit 1
        fi
    
    # ===============================================
    # LoadBalancer 설정 확인 및 접속 URL 제공
    # ===============================================
    - name: Get Application URL
      if: success() && github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🔗 애플리케이션 접속 정보 확인 중..."
        
        # ALB 정보 확인
        ALB_DNS=$(aws elbv2 describe-load-balancers --query 'LoadBalancers[?contains(LoadBalancerName, `walb-app`)].DNSName' --output text 2>/dev/null || echo "")
        
        if [ -n "$ALB_DNS" ]; then
          echo "🌐 애플리케이션 접속 URL: http://$ALB_DNS"
        else
          echo "ℹ️ LoadBalancer DNS를 찾을 수 없습니다. kubectl port-forward를 사용하세요:"
          echo "kubectl port-forward -n ${{ env.PROJECT_NAME }} svc/${{ env.PROJECT_NAME }}-service 8080:80"
        fi
    
    # ===============================================
    # 배포 완료 알림
    # ===============================================
    - name: Application Deployment Notification
      if: success() && github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🎉 PHP 애플리케이션 배포 완료!"
        echo "프로젝트: ${{ env.PROJECT_NAME }}"
        echo "이미지: ${{ steps.build-image.outputs.image }}"
        echo "클러스터: ${{ env.EKS_CLUSTER_NAME }}"
        echo "네임스페이스: ${{ env.PROJECT_NAME }}"
        echo "데이터베이스: ${{ env.RDS_ENDPOINT }}"
        echo "커밋: ${{ github.sha }}"
        echo "배포 시간: $(date)"
        
        # 배포된 서비스 정보 출력
        kubectl get all -n ${{ env.PROJECT_NAME }}

    # ===============================================
    # 배포 실패 시 롤백
    # ===============================================
    - name: Rollback on failure
      if: failure() && github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "❌ 배포 실패 - 이전 버전으로 롤백 중..."
        kubectl rollout undo deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} || true
        kubectl rollout status deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --timeout=300s || true
        echo "✅ 롤백 시도 완료"